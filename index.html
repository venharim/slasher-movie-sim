<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Slasher Movie Simulator</title>
<style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }


        @keyframes bloodDrip {
            0% { transform: translateY(-10px); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: translateY(20px); opacity: 0; }
        }


        @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }


        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }


        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }


        @keyframes fadeInUp {
            from { 
                opacity: 0; 
                transform: translateY(30px); 
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }


        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }


        @keyframes minimizeWidget {
            from { transform: scale(1); }
            50% { transform: scale(0.95); }
            to { transform: scale(1); }
        }


        @keyframes maximizeWidget {
            from { transform: scale(0.95); }
            to { transform: scale(1); }
        }


        .audio-controls.minimizing {
            animation: minimizeWidget 0.3s ease;
        }


        .audio-controls.maximizing {
            animation: maximizeWidget 0.3s ease;
        }


        .blood-particle {
            position: absolute;
            width: 4px;
            height: 8px;
            background: #ff0000;
            border-radius: 50%;
            animation: bloodDrip 2s ease-in-out infinite;
            pointer-events: none;
        }


        .flicker-effect {
            animation: flicker 0.3s ease-in-out;
        }


        .pulse-effect {
            animation: pulse 0.5s ease-in-out;
        }


        .shake-effect {
            animation: shake 0.5s ease-in-out;
        }


        .audio-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: rgba(30, 30, 30, 0.95);
            padding: 15px;
            border-radius: 8px;
            border: 2px solid #555;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            transition: all 0.3s ease;
            user-select: none;
            backdrop-filter: blur(10px);
            min-width: 200px;
        }


        .audio-controls:hover {
            border-color: #ff4444;
            box-shadow: 0 4px 25px rgba(255, 68, 68, 0.3);
        }


        .audio-controls.minimized {
            padding: 8px 12px;
            min-width: auto;
        }


        .audio-controls.minimized .audio-content {
            display: none;
        }


        .audio-controls.dragging {
            transition: none;
            cursor: grabbing;
        }


        .audio-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            cursor: grab;
            padding: 4px 0;
            border-bottom: 1px solid #555;
        }


        .audio-header:active {
            cursor: grabbing;
        }


        .audio-title {
            color: #fff;
            font-size: 12px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 6px;
        }


        .minimize-btn {
            background: #555 !important;
            color: #fff !important;
            border: none;
            padding: 4px 8px !important;
            border-radius: 3px;
            cursor: pointer;
            font-size: 10px !important;
            margin: 0 !important;
            transition: all 0.2s ease;
        }


        .minimize-btn:hover {
            background: #ff4444 !important;
            transform: scale(1.1);
        }


        .audio-content {
            transition: all 0.3s ease;
        }


        .audio-controls button {
            background: #ff4444;
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s ease;
        }


        .audio-controls button:hover {
            background: #ff6666;
            transform: translateY(-1px);
        }


        .audio-controls button.muted {
            background: #666;
        }


        .volume-slider {
            width: 80px;
            margin-left: 10px;
        }


        .drag-indicator {
            opacity: 0.5;
            transition: opacity 0.2s ease;
        }


        .audio-header:hover .drag-indicator {
            opacity: 1;
        }


        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #0a0a0a 0%, #1a0505 100%);
            color: #fff;
            min-height: 100vh;
            padding: 20px;
        }


        .container {
            max-width: 1400px;
            margin: 0 auto;
        }


        .header {
            text-align: center;
            margin-bottom: 30px;
        }


        .header h1 {
            font-size: 3rem;
            color: #ff4444;
            text-shadow: 0 0 20px #ff4444;
            margin-bottom: 10px;
        }


        .header .subtitle {
            color: #ccc;
            font-size: 1.2rem;
            margin-bottom: 5px;
        }


        .header .tagline {
            color: #ff6666;
            font-style: italic;
        }


        .section {
            background: rgba(30, 30, 30, 0.9);
            border: 2px solid #ff4444;
            border-radius: 10px;
            padding: 25px;
            margin-bottom: 25px;
        }


        .section h2 {
            color: #ff4444;
            font-size: 1.8rem;
            margin-bottom: 20px;
            text-transform: uppercase;
        }


        .form-group {
            margin-bottom: 20px;
        }


        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #fff;
        }


        input, select, textarea {
            width: 100%;
            padding: 12px;
            background: #2a2a2a;
            border: 1px solid #555;
            border-radius: 5px;
            color: #fff;
            font-size: 16px;
        }


        input:focus, select:focus, textarea:focus {
            outline: none;
            border-color: #ff4444;
            box-shadow: 0 0 10px rgba(255, 68, 68, 0.3);
        }


        .cast-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }


        .character-card {
            background: #333;
            border: 1px solid #555;
            border-radius: 8px;
            padding: 20px;
        }


        .character-card.returning {
            border: 2px solid #4CAF50;
            background: rgba(76, 175, 80, 0.1);
        }


        .character-header {
            display: flex;
            align-items: center;
            margin-bottom: 15px;
        }


        .character-avatar {
            width: 60px;
            height: 60px;
            background: #555;
            border-radius: 50%;
            margin-right: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
        }


        .character-info h3 {
            margin-bottom: 5px;
            color: #fff;
        }


        .character-info .archetype {
            color: #ff4444;
            font-style: italic;
        }


        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }


        .stat {
            margin-bottom: 10px;
        }


        .stat-label {
            font-size: 12px;
            color: #ccc;
            margin-bottom: 3px;
        }


        .stat-bar {
            height: 8px;
            background: #444;
            border-radius: 4px;
            overflow: hidden;
        }


        .stat-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8888, #ffaa44);
            background-size: 200% 100%;
            animation: shimmer 2s ease-in-out infinite;
            transition: width 0.3s ease;
        }


        .survival-chance {
            margin-top: 10px;
            padding: 8px;
            background: rgba(255, 68, 68, 0.1);
            border-radius: 4px;
            text-align: center;
            font-weight: bold;
            color: #4CAF50;
        }


        .btn {
            background: linear-gradient(135deg, #ff4444, #cc3333);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            text-transform: uppercase;
            transition: all 0.3s ease;
            margin: 10px 5px;
        }


        .btn:hover {
            background: linear-gradient(135deg, #ff6666, #ff4444);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(255, 68, 68, 0.4);
        }


        .btn-secondary {
            background: linear-gradient(135deg, #666, #444);
        }


        .btn-secondary:hover {
            background: linear-gradient(135deg, #777, #555);
        }


        .movie-log {
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
            max-height: 400px;
            overflow-y: auto;
        }


        .event {
            background: rgba(255, 68, 68, 0.1);
            border-left: 4px solid #ff4444;
            padding: 12px;
            margin: 10px 0;
            border-radius: 0 5px 5px 0;
            animation: fadeInUp 0.5s ease-out;
        }


        .event.title {
            border-left-color: #ff4444;
            background: rgba(255, 68, 68, 0.2);
            font-weight: bold;
            font-size: 1.2rem;
            text-align: center;
        }


        .event.narrative {
            border-left-color: #888;
            background: rgba(136, 136, 136, 0.1);
            font-style: italic;
        }


        .event.killer-thought {
            border-left-color: #8e24aa;
            background: rgba(142, 36, 170, 0.1);
            font-style: italic;
            color: #e1bee7;
        }


        .event.death {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }


        .event.death::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 49%, rgba(255, 0, 0, 0.1) 50%, transparent 51%);
            pointer-events: none;
        }


        .event.attack {
            border-left-color: #ff8800;
            background: rgba(255, 136, 0, 0.1);
        }


        .event.reveal, .event.event {
            border-left-color: #8800ff;
            background: rgba(136, 0, 255, 0.1);
        }


        .event.dialogue {
            font-style: italic;
            color: #aaa;
            border-left-color: #666;
            background: rgba(102, 102, 102, 0.1);
        }


        .event.red-herring {
            background: rgba(255, 255, 0, 0.1);
            border-left-color: #ffff00;
        }


        .final-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
        }


        .final-table th {
            background: #ff4444;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }


        .final-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #444;
        }


        .final-table tr:hover {
            background: rgba(255, 68, 68, 0.1);
        }


        .status-alive { background: #4CAF50; color: white; padding: 4px 8px; border-radius: 3px; }
        .status-dead { background: #f44336; color: white; padding: 4px 8px; border-radius: 3px; }
        .status-attacked { background: #ff9800; color: white; padding: 4px 8px; border-radius: 3px; }
        .status-killed { background: #d32f2f; color: white; padding: 4px 8px; border-radius: 3px; }
        .status-killer { background: #9c27b0; color: white; padding: 4px 8px; border-radius: 3px; }
        .status-n\/a { background: #666; color: #ccc; padding: 4px 8px; border-radius: 3px; }


        .edgic-table {
            margin-top: 30px;
        }


        .franchise-history {
            margin-top: 40px;
        }


        .franchise-history h3 {
            color: #ff4444;
            font-size: 1.5rem;
            margin-bottom: 15px;
            text-transform: uppercase;
        }


        .edgic-cell {
            text-align: center;
            font-weight: bold;
            padding: 8px 4px;
            border-radius: 3px;
        }


        /* UTR ratings - lightest tones */
        .edgic-utr { background: #F4A460; color: white; } /* Sandy brown - neutral UTR */
        .edgic-utrp { background: #DDA0DD; color: white; } /* Plum - positive UTR */
        .edgic-utrn { background: #CD853F; color: white; } /* Peru - negative UTR */
        .edgic-utrm { background: #D2691E; color: white; } /* Chocolate - mixed UTR */


        /* MOR ratings - medium tones */
        .edgic-mor { background: #FFD700; color: black; } /* Gold - neutral MOR */
        .edgic-morp { background: #DA70D6; color: white; } /* Orchid - positive MOR */
        .edgic-morn { background: #9370DB; color: white; } /* Medium slate blue - negative MOR */
        .edgic-morm { background: #8FBC8F; color: white; } /* Dark sea green - mixed MOR */


        /* CP ratings - strongest tones */
        .edgic-cp { background: #20B2AA; color: white; } /* Light sea green - neutral CP */
        .edgic-cpp { background: #4169E1; color: white; } /* Royal blue - positive CP */
        .edgic-cpn { background: #8A2BE2; color: white; } /* Blue violet - negative CP */
        .edgic-cpm { background: #008B8B; color: white; } /* Dark cyan - mixed CP */


        /* OTT ratings - most dramatic */
        .edgic-ott { background: #32CD32; color: white; } /* Lime green - neutral OTT */
        .edgic-ottp { background: #00FF7F; color: white; } /* Spring green - positive OTT */
        .edgic-ottn { background: #FF0000; color: white; } /* Red - negative OTT */
        .edgic-ottm { background: #228B22; color: white; } /* Forest green - mixed OTT */


        /* Special cases */
        .edgic-inv { background: #333; color: #666; } /* Invisible */
        .edgic-dead { background: #666; color: #ccc; } /* Dead */
        .edgic-na { background: #444; color: #888; } /* Not available */


        .killer-reveal {
            background: linear-gradient(135deg, #8e24aa, #5e35b1);
            padding: 30px;
            border-radius: 10px;
            text-align: center;
            margin: 30px 0;
            animation: pulse 2s ease-in-out infinite;
        }


        .killer-reveal h3 {
            color: white;
            font-size: 2rem;
            margin-bottom: 15px;
        }


        .motive-text {
            color: #e1bee7;
            font-size: 1.1rem;
            line-height: 1.6;
            margin: 15px 0;
        }


        .hidden {
            display: none;
        }


        .progress-bar {
            width: 100%;
            height: 20px;
            background: #333;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px 0;
        }


        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4444, #ff8888, #ffaa44);
            background-size: 200% 100%;
            animation: shimmer 3s ease-in-out infinite;
            transition: width 0.5s ease;
        }


        /* Relationship System Styles */
        .relationship-highlight {
            background: rgba(76, 175, 80, 0.2);
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            border: 2px solid #4CAF50;
        }


        .relationship-pair {
            background: #333;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid #555;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
        }


        .relationship-selector {
            background: #2a2a2a;
            color: #fff;
            border: 1px solid #555;
            padding: 8px;
            border-radius: 4px;
            min-width: 150px;
        }


        @media (max-width: 768px) {
            .cast-grid {
                grid-template-columns: 1fr;
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body>
<!-- Audio Controls -->
<div class="audio-controls" id="audio-widget">
<div class="audio-header" id="audio-drag-handle">
<div class="audio-title">
<span class="drag-indicator">⋮⋮</span>
                🔊 Audio Controls
            </div>
<button class="minimize-btn" id="minimize-audio" onclick="toggleAudioWidget()">−</button>
</div>
<div class="audio-content" id="audio-content">
<button id="toggle-ambient" onclick="toggleAmbient()">🌙 Ambient</button>
<button id="toggle-sfx" onclick="toggleSFX()">🔪 SFX</button>
<button id="toggle-music" onclick="toggleMusic()">🎵 Music</button>
<br/>
<label style="color: #fff; font-size: 11px;">Volume:</label>
<input class="volume-slider" id="master-volume" max="100" min="0" onchange="setMasterVolume(this.value)" type="range" value="30"/>
</div>
</div>
<div class="container">
<div class="header">
<h1>💀 SLASHER MOVIE SIMULATOR 💀</h1>
<div class="subtitle">Inspired by the Slasher genre</div>
<div class="tagline">The killer is among us...</div>
<div style="background: rgba(76, 175, 80, 0.2); padding: 10px; border-radius: 8px; margin-top: 15px; border: 2px solid #4CAF50;">
<span style="color: #4CAF50; font-weight: bold; font-size: 1.1rem;">🔗 NOW WITH RELATIONSHIP SYSTEM!</span>
<div style="color: #ccc; font-size: 0.9rem; margin-top: 5px;">Define romantic couples, best friends, enemies &amp; family bonds that affect survival!</div>
</div>
</div>
<div id="setup-screen">
<div class="section">
<h2>Movie Setup</h2>
<div class="form-group">
<label for="movie-title">Movie Title</label>
<input id="movie-title" placeholder="Enter your horror movie title..." type="text"/>
</div>
<div class="form-group">
<label for="movie-year">Release Year</label>
<input id="movie-year" max="2030" min="1970" placeholder="2025" type="number" value="2025"/>
</div>
<div class="form-group">
<label for="game-mode">Game Mode</label>
<select id="game-mode">
<option value="spectator">Spectator (Killer hidden)</option>
<option value="killer">Play as Killer</option>
</select>
</div>
<div class="form-group">
<label for="cast-size">Cast Size</label>
<select id="cast-size">
<option value="6">6 characters</option>
<option selected="" value="8">8 characters</option>
<option value="10">10 characters</option>
<option value="12">12 characters</option>
<option value="15">15 characters</option>
</select>
</div>
<div class="form-group">
<label for="movie-setting">Movie Setting</label>
<select id="movie-setting" onchange="toggleCustomSetting()">
<option value="random">Random Setting</option>
<option value="crimson-falls">Crimson Falls - isolated mountain town where autumn mist clings to abandoned cabins</option>
<option value="willowbrook">Willowbrook - forgotten lakeside community where dark waters hold deadly secrets</option>
<option value="ravenshollow">Ravenshollow - remote college town where ivy-covered halls echo with screams</option>
<option value="cedar-ridge">Cedar Ridge - snowbound village where winter winds carry whispers of murder</option>
<option value="driftwood-bay">Driftwood Bay - sleepy coastal town where lighthouse beams reveal unspeakable horrors</option>
<option value="harvest-moon">Harvest Moon - agricultural settlement where cornfields hide more than just crops</option>
<option value="shadowbrook">Shadowbrook - abandoned mining town where old tunnels conceal fresh graves</option>
<option value="custom">Custom Setting...</option>
</select>
</div>
<div class="form-group hidden" id="custom-setting-fields">
<label for="custom-location">Custom Location Name</label>
<input id="custom-location" placeholder="e.g., Blackwood Manor, Devil's Lake, Pine Ridge Academy..." type="text"/>
<label for="custom-atmosphere" style="margin-top: 10px;">Atmospheric Description</label>
<input id="custom-atmosphere" placeholder="e.g., where ancient trees whisper dark secrets..." type="text"/>
</div>
<div class="form-group">
<label for="killer-count">Number of Killers</label>
<select id="killer-count">
<option value="random">Random (1-3)</option>
<option value="1">1 Killer</option>
<option value="2">2 Killers</option>
<option value="3">3 Killers</option>
</select>
</div>
<button class="btn" id="create-cast-btn" onclick="setupCast()">Create Cast</button>
<button class="btn btn-secondary" onclick="alert('Test button works!')" style="margin-left: 10px;">Test Button</button>
<button class="btn" onclick="testRelationshipSystem()" style="margin-left: 10px; background: #4CAF50;">🔗 Test Relationships</button>
</div>
<div class="section hidden" id="cast-customization">
<h2>Cast Customization</h2>
<div style="background: rgba(76, 175, 80, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #4CAF50;">
<h3 style="color: #4CAF50; margin-bottom: 10px;">🔗 NEW: Relationship System Available!</h3>
<p style="color: #ccc; margin: 0;">After customizing your characters, you can define relationships between them (romantic couples, best friends, enemies, etc.) that will affect the story, survival chances, and dialogue!</p>
</div>
<div class="cast-grid" id="cast-container"></div>
</div>
</div>
<div class="hidden" id="movie-screen">
<div class="section">
<h2 id="current-movie-title"></h2>
<div class="progress-bar">
<div class="progress-fill" id="movie-progress"></div>
</div>
<div id="current-act-display"></div>
<!-- Cast Grid Status -->
<div id="cast-grid-status" style="margin-top: 10px; display: flex; flex-wrap: wrap; gap: 8px;"></div>
</div>
<div class="section">
<div class="movie-log" id="movie-log"></div>
<div style="text-align: center; margin: 20px 0;">
<button class="btn" id="continue-btn" onclick="continueStory()" style="display: none;">Continue Story</button>
<button class="btn" id="autoplay-btn" onclick="toggleAutoplay()">Enable Autoplay</button>
<button class="btn btn-secondary" id="skip-btn" onclick="skipToEnd()" style="display: none;">Skip to End</button>
<button class="btn" id="view-results-btn" onclick="viewResults()" style="display: none;">View Final Results</button>
</div>
<div id="story-status" style="text-align: center; color: #ccc; margin: 10px 0;"></div>
</div>
<div class="section hidden" id="killer-controls">
<h2>Killer Actions</h2>
<div id="killer-targets"></div>
<div style="text-align: center; margin-top: 15px;">
<button class="btn" id="force-killer-action" onclick="forceKillerAction()" style="display: none; background: #8B0000; font-size: 18px; padding: 20px 30px;">
                        🔪 TAKE KILLER ACTION NOW 🔪
                    </button>
<p id="killer-help-text" style="color: #ff6666; margin-top: 10px; display: none;">
                        Click "Continue Story" to get killer opportunities, or use the button above to force an action anytime!
                    </p>
</div>
</div>
</div>
<div class="hidden" id="results-screen">
<div class="section">
<h2 id="final-title"></h2>
<div id="killer-reveal-section"></div>
<div class="final-table-container">
<h3>Final Body Count</h3>
<table class="final-table" id="final-body-count">
<thead>
<tr>
<th>Character</th>
<th>Archetype</th>
<th>Act 1</th>
<th>Act 2</th>
<th>Act 3</th>
<th>Final Status</th>
<th>Killed By</th>
</tr>
</thead>
<tbody id="final-body-tbody"></tbody>
</table>
</div>
<div class="edgic-table">
<h3>Horror Movie Edgic Analysis</h3>
<table class="final-table" id="edgic-analysis">
<thead>
<tr>
<th>Character</th>
<th>Archetype</th>
<th>Act 1</th>
<th>Act 2</th>
<th>Act 3</th>
</tr>
</thead>
<tbody id="edgic-tbody"></tbody>
</table>
</div>
<button class="btn" onclick="createSequel()">Create Sequel</button>
<button class="btn btn-secondary" onclick="resetSimulator()">Create New Horror</button>
</div>
</div>
</div>
<script>
        // Character archetypes and names
        const archetypes = [
            { name: 'The Final Girl', description: 'Pure-hearted and resourceful, destined to survive', stats: { survival: 9, intelligence: 8, social: 6, athletics: 7, stealth: 6, luck: 8 } },
            { name: 'The Flirt', description: 'Seductive but often meets a grisly end', stats: { survival: 3, intelligence: 5, social: 9, athletics: 6, stealth: 4, luck: 4 } },
            { name: 'The Jock', description: 'Strong and athletic but often overconfident', stats: { survival: 5, intelligence: 4, social: 7, athletics: 9, stealth: 3, luck: 5 } },
            { name: 'The Nerd', description: 'Smart and analytical, often discovers clues', stats: { survival: 6, intelligence: 9, social: 3, athletics: 2, stealth: 7, luck: 6 } },
            { name: 'The Stoner', description: 'Laid-back and oblivious to danger', stats: { survival: 2, intelligence: 3, social: 6, athletics: 4, stealth: 5, luck: 3 } },
            { name: 'The Rich Girl', description: 'Entitled and pampered, easy target', stats: { survival: 2, intelligence: 5, social: 8, athletics: 3, stealth: 2, luck: 7 } },
            { name: 'The Bad Boy', description: 'Rebellious with a dark past', stats: { survival: 6, intelligence: 6, social: 7, athletics: 8, stealth: 8, luck: 4 } },
            { name: 'The Innocent', description: 'Pure and naive, tugs at heartstrings', stats: { survival: 4, intelligence: 6, social: 8, athletics: 4, stealth: 6, luck: 7 } },
            { name: 'The Outcast', description: 'Mysterious loner with secrets', stats: { survival: 7, intelligence: 8, social: 2, athletics: 5, stealth: 9, luck: 5 } },
            { name: 'The Party Girl', description: 'Lives for fun and excitement', stats: { survival: 3, intelligence: 4, social: 9, athletics: 6, stealth: 3, luck: 5 } },
            { name: 'The Skeptic', description: 'Doesn\'t believe in the supernatural', stats: { survival: 5, intelligence: 8, social: 5, athletics: 6, stealth: 6, luck: 4 } },
            { name: 'The Hero', description: 'Brave protector of others', stats: { survival: 7, intelligence: 7, social: 8, athletics: 8, stealth: 5, luck: 6 } },
            { name: 'The Coward', description: 'First to run, sometimes survives', stats: { survival: 6, intelligence: 6, social: 4, athletics: 7, stealth: 8, luck: 8 } },
            { name: 'The Goth', description: 'Dark-humored, witty, and enigmaticly unbothered', stats: { survival: 8, intelligence: 8, social: 4, athletics: 2, stealth: 9, luck: 5 } },
            { name: 'The Tomboy', description: 'Tough and independent', stats: { survival: 7, intelligence: 7, social: 5, athletics: 8, stealth: 7, luck: 6 } },
            { name: 'The Drama Queen', description: 'Attention-seeking and dramatic', stats: { survival: 3, intelligence: 5, social: 8, athletics: 4, stealth: 2, luck: 4 } },
            { name: 'The Boyfriend', description: 'Devoted partner, often protective', stats: { survival: 5, intelligence: 6, social: 7, athletics: 7, stealth: 5, luck: 5 } },
            { name: 'The Best Friend', description: 'Loyal companion to the protagonist', stats: { survival: 6, intelligence: 7, social: 9, athletics: 5, stealth: 6, luck: 6 } },
            { name: 'The Reporter', description: 'Investigative journalist seeking the truth', stats: { survival: 6, intelligence: 8, social: 8, athletics: 5, stealth: 6, luck: 5 } },
            { name: 'The Horror Fanatic', description: 'Knows all the rules but may be overconfident', stats: { survival: 7, intelligence: 7, social: 6, athletics: 5, stealth: 6, luck: 4 } }
        ];


        const names = [
         'Emma', 'Liam', 'Olivia', 'Noah', 'Ava', 'Ethan', 'Sophia', 'Mason', 'Isabella', 'William',
  'Mia', 'James', 'Charlotte', 'Benjamin', 'Amelia', 'Lucas', 'Harper', 'Henry', 'Evelyn', 'Alexander',
  'Abigail', 'Michael', 'Emily', 'Elijah', 'Elizabeth', 'Daniel', 'Mila', 'Matthew', 'Ella', 'Jackson',
  'Madison', 'David', 'Scarlett', 'Sebastian', 'Victoria', 'Joseph', 'Aria', 'Samuel', 'Grace', 'John',
  'Chloe', 'Owen', 'Camila', 'Wyatt', 'Penelope', 'Jack', 'Riley', 'Luke', 'Layla', 'Jayden',
  'Luna', 'Dylan', 'Zoe', 'Gabriel', 'Nora', 'Aiden', 'Lily', 'Anthony', 'Hannah', 'Isaac',
  'Addison', 'Grayson', 'Ellie', 'Andrew', 'Zoey', 'Christopher', 'Stella', 'Joshua', 'Natalie', 'Jaxon',
  'Leah', 'Julian', 'Hazel', 'Nathan', 'Violet', 'Aaron', 'Aurora', 'Lincoln', 'Savannah', 'Christian',
  'Audrey', 'Hunter', 'Brooklyn', 'Cameron', 'Bella', 'Connor', 'Claire', 'Eli', 'Skylar', 'Ezra',
  'Lucy', 'Thomas', 'Paisley', 'Charles', 'Everly', 'Caleb', 'Anna', 'Isaiah', 'Caroline', 'Ryan',
  'Nova', 'Adrian', 'Genesis', 'Nolan', 'Kennedy', 'Jeremiah', 'Samantha', 'Easton', 'Aaliyah', 'Ezekiel',
  'Cora', 'Colton', 'Ruby', 'Brayden', 'Eva', 'Jordan', 'Serenity', 'Angel', 'Autumn', 'Roman',
  'Alice', 'Austin', 'Hailey', 'Dominic', 'Gianna', 'Adam', 'Sadie', 'Xavier', 'Quinn', 'Jose',
  'Nevaeh', 'Jace', 'Piper', 'Levi', 'Kinsley', 'Jonathan', 'Clara', 'Christopher', 'Rylee', 'Hudson',
  'Athena', 'Robert', 'Melanie', 'Ian', 'Naomi', 'Carson', 'Eliza', 'Axel', 'Isla', 'Miles',
  'Josephine', 'Jason', 'Lyla', 'Declan', 'Katherine', 'Brandon', 'Brielle', 'Weston', 'Arya', 'Justin',
  'Ivy', 'Parker', 'Jade', 'Luis', 'Rose', 'Diego', 'Maria', 'Greyson', 'Liliana', 'Kevin',
  'Margaret', 'Zachary', 'Adeline', 'Tyler', 'Raelynn', 'Bentley', 'Melody', 'Brody', 'Julia', 'Max',
  'Maya', 'Juan', 'Valentina', 'Kaiden', 'Reagan', 'Asher', 'Lilly', 'Carlos', 'Ashley', 'Micah',
  'Athena', 'Vincent', 'Ariana', 'George', 'Elena', 'Maverick', 'Sophie', 'Giovanni', 'Brianna', 'Maxwell',
  'Juliette', 'Kingston', 'Alexandra', 'Jayce', 'Harmony', 'Kayden', 'Blakely', 'Ayden', 'Isabel', 'Rowan',
  'Faith', 'Braxton', 'Andrea', 'Ryker', 'Londyn', 'Ivan', 'Makayla', 'Beau', 'Emery', 'Camden',
  'Adalynn', 'Sawyer', 'Jocelyn', 'Harrison', 'Nicole', 'Gavin', 'Vivienne', 'Leonardo', 'Lena', 'Emmett',
  'Gabriella', 'Kailey', 'Tucker', 'Alina', 'August', 'Mckenzie', 'Finn', 'Rebecca', 'Rhett', 'Brooklynn',
  'Zion', 'Dakota', 'Bennett', 'Anastasia', 'Kaleb', 'Alaina', 'Joel', 'Phoebe', 'Grant', 'Rachel',
  'Ryder', 'Angela', 'Emiliano', 'Tessa', 'Alan', 'Leila', 'Victor', 'Daisy', 'Abel', 'Elise',
  'Matteo', 'Lucia', 'Nicolas', 'Genevieve', 'Archer', 'Alayna', 'Jasper', 'Camille', 'Maddox', 'Thea',
  'Knox', 'Freya', 'Malachi', 'Amaya', 'Zayden', 'Ruth', 'Erick', 'Selena', 'Jude', 'Adelyn',
  'Pedro', 'Charlee', 'Spencer', 'Journee', 'Tristan', 'Harmony', 'Messiah', 'Annabelle', 'Manuel', 'Arabella',
  'Karter', 'Fiona', 'Cody', 'Nina', 'Paxton', 'Brynlee', 'Lane', 'Kate', 'Phoenix', 'Laila',
  'Remington', 'Jayla', 'Brantley', 'Kayla', 'Bryson', 'Alani', 'Sergio', 'Adrianna', 'Colt', 'Ember',
  'Troy', 'Dakota', 'Ricardo', 'Talia', 'Zane', 'Miranda', 'Francisco', 'Catalina', 'Kyrie', 'Heidi',
  'Shane', 'Daniella', 'Seth', 'Veronica', 'Marshall', 'Marley', 'Wade', 'Giselle', 'Jett', 'Malia',
  'Andy', 'Annie', 'Desmond', 'Gwendolyn', 'Ali', 'Joy', 'Edwin', 'Helen', 'Tobias', 'Lucille',
  'Armando', 'Yaretzi', 'Gage', 'Angelina', 'Edgar', 'Amira', 'Cohen', 'Evangeline', 'Niko', 'Francesca',
  'Fabian', 'April', 'Ari', 'Julianna', 'Corbin', 'Esmeralda', 'Koa', 'Laura', 'Saul', 'Mira',
  'Zander', 'Daphne', 'Omari', 'Lana', 'Reid', 'Ophelia', 'Kian', 'Cecilia', 'Derek', 'Adelaide',
  'Cash', 'Nylah', 'Kellan', 'Elliott', 'Moses', 'Winter', 'Reed', 'Celeste', 'Finley', 'Lara', 'Figgy', 'Feng', 'Forrest'
        ];


        // Game state
        let gameState = {
            characters: [],
            killers: [],
            gameMode: 'spectator',
            currentAct: 1,
            movieTitle: '',
            movieYear: new Date().getFullYear(),
            movieSetting: 'random',
            events: [],
            isKillerMode: false,
            killerPlayer: null,
            autoPlay: false,
            movieComplete: false,
            storyQueue: [],
            currentStoryIndex: 0,
            relationships: new Map(), // Track all character relationships
            narrativeState: {
                suspicionLevels: new Map(), // Track who suspects whom
                groupDynamics: [], // Current group formations
                currentLocation: 'house',
                timeOfDay: 'evening',
                dangerLevel: 'low' // low, medium, high, extreme
            }
        };


        // Franchise history tracking
        let franchiseHistory = {
            movies: [],
            allCharacters: new Map() // Map character names to their info across movies
        };


        // Relationship System
        const relationshipTypes = {
            ROMANTIC: { name: 'Romantic Couple', emoji: '💕', survivalBonus: 2, loyaltyBonus: 3 },
            BEST_FRIENDS: { name: 'Best Friends', emoji: '👥', survivalBonus: 1, loyaltyBonus: 2 },
            FAMILY: { name: 'Family', emoji: '👪', survivalBonus: 2, loyaltyBonus: 3 },
            ENEMIES: { name: 'Enemies', emoji: '⚔️', survivalBonus: -1, loyaltyBonus: -2 },
            EX_LOVERS: { name: 'Ex-Lovers', emoji: '💔', survivalBonus: -1, loyaltyBonus: -1 },
            NEUTRAL: { name: 'Neutral', emoji: '🤝', survivalBonus: 0, loyaltyBonus: 0 }
        };


        // Relationship helper functions
        function createRelationship(char1, char2, type) {
            const key = `${Math.min(char1.id, char2.id)}-${Math.max(char1.id, char2.id)}`;
            gameState.relationships.set(key, {
                characters: [char1.id, char2.id],
                type: type,
                strength: Math.floor(Math.random() * 3) + 3, // 3-5 strength
                history: []
            });
        }


        function getRelationship(char1, char2) {
            const key = `${Math.min(char1.id, char2.id)}-${Math.max(char1.id, char2.id)}`;
            return gameState.relationships.get(key);
        }


        function getCharacterRelationships(character) {
            const relationships = [];
            gameState.relationships.forEach((rel, key) => {
                if (rel.characters.includes(character.id)) {
                    const otherId = rel.characters.find(id => id !== character.id);
                    const otherChar = gameState.characters.find(c => c.id === otherId);
                    if (otherChar) {
                        relationships.push({ character: otherChar, relationship: rel });
                    }
                }
            });
            return relationships;
        }


        function findCharactersByRelationType(type) {
            const pairs = [];
            gameState.relationships.forEach((rel, key) => {
                if (rel.type === type) {
                    const char1 = gameState.characters.find(c => c.id === rel.characters[0]);
                    const char2 = gameState.characters.find(c => c.id === rel.characters[1]);
                    if (char1 && char2) {
                        pairs.push([char1, char2]);
                    }
                }
            });
            return pairs;
        }


        function testRelationshipSystem() {
            alert('🔗 Relationship System Test!\n\nTo see the full relationship system:\n\n1. Click "Create Cast" button\n2. Customize your characters\n3. Look for "Setup Relationships & Start Movie" button\n4. Click it to see the relationship setup screen!\n\nThe relationship system adds:\n💕 Romantic couples\n👥 Best friends\n👪 Family bonds\n⚔️ Enemies\n💔 Ex-lovers\n\nThese affect survival chances, dialogue, and story events!');
            
            // Quick demo of relationship types
            console.log('Available relationship types:', relationshipTypes);
        }


        // Enhanced Character Memory System
        class CharacterMemory {
            constructor(characterId) {
                this.characterId = characterId;
                this.experiences = [];
                this.suspicions = new Map(); // suspectId -> { level, reasons, evidence, timestamp }
                this.trust = new Map(); // characterId -> trust level (0-1)
                this.emotionalState = 'calm';
                this.witnessedDeaths = [];
                this.lastKnownLocation = '';
                this.clues = []; // { type, description, location, act, timestamp }
                this.behaviorPattern = 'normal'; // normal, cautious, aggressive, paranoid, broken
                this.knownFacts = new Set(); // Things they've figured out
                this.allies = new Set(); // CharacterIds they trust and group with
                this.traumaLevel = 0; // 0-10 scale of accumulated trauma
                this.survivalExperience = 0; // Increases survival chances over time
            }

            addExperience(event) {
                this.experiences.push({
                    ...event,
                    timestamp: Date.now(),
                    act: gameState.currentAct
                });
                this.updateEmotionalState(event);
            }

            updateEmotionalState(event) {
                const character = gameState.characters.find(c => c.id === this.characterId);
                if (!character) return;

                // Increase trauma and survival experience
                this.traumaLevel += this.getTraumaImpact(event);
                this.survivalExperience += this.getSurvivalLearning(event);

                // Update behavior pattern based on trauma
                this.updateBehaviorPattern();

                switch(event.type) {
                    case 'death':
                        this.witnessedDeaths.push(event.victim);
                        this.processDeathEvidence(event);
                        
                        if (this.witnessedDeaths.length >= 3) {
                            this.emotionalState = 'broken';
                        } else if (event.victim && getRelationship(character, event.victim)) {
                            this.emotionalState = 'devastated';
                        } else {
                            this.emotionalState = 'terrified';
                        }
                        break;
                    case 'attack':
                        this.emotionalState = 'panicked';
                        this.processAttackEvidence(event);
                        break;
                    case 'discovery':
                        this.emotionalState = 'suspicious';
                        this.processDiscoveryEvidence(event);
                        break;
                    case 'suspicious_behavior':
                        this.processSuspiciousBehavior(event);
                        break;
                    case 'safe_moment':
                        if (this.witnessedDeaths.length === 0) {
                            this.emotionalState = 'calm';
                        } else {
                            this.emotionalState = 'nervous';
                        }
                        break;
                }
            }

            getTraumaImpact(event) {
                switch(event.type) {
                    case 'death': return event.isClose ? 2 : 1;
                    case 'attack': return event.isPersonal ? 1.5 : 0.5;
                    case 'discovery': return 0.3;
                    default: return 0.1;
                }
            }

            getSurvivalLearning(event) {
                switch(event.type) {
                    case 'death': return 1; // Learn from others' deaths
                    case 'attack': return event.survived ? 2 : 0; // Big learning if survived attack
                    case 'discovery': return 0.5; // Learn from investigation
                    default: return 0.1;
                }
            }

            updateBehaviorPattern() {
                if (this.traumaLevel >= 8) {
                    this.behaviorPattern = 'broken';
                } else if (this.traumaLevel >= 6) {
                    this.behaviorPattern = 'paranoid';
                } else if (this.traumaLevel >= 4) {
                    this.behaviorPattern = 'cautious';
                } else if (this.survivalExperience >= 3) {
                    this.behaviorPattern = 'aggressive';
                } else {
                    this.behaviorPattern = 'normal';
                }
            }

            processDeathEvidence(event) {
                if (!event.killer) return;
                
                // Add suspicion to the killer
                this.addSuspicion(event.killer.id, 'witnessed_murder', 0.9, 'I saw them kill someone!');
                
                // Add clue about location and method
                this.clues.push({
                    type: 'murder_scene',
                    description: `${event.victim.name} was killed here`,
                    location: event.location || 'unknown',
                    act: gameState.currentAct,
                    timestamp: Date.now()
                });
            }

            processAttackEvidence(event) {
                if (!event.attacker) return;
                
                this.addSuspicion(event.attacker.id, 'witnessed_attack', 0.7, 'I saw them attack someone!');
                
                // Learn about killer patterns
                this.knownFacts.add(`killer_uses_${event.method || 'violence'}`);
            }

            processDiscoveryEvidence(event) {
                if (event.clue) {
                    this.clues.push({
                        type: event.clue.type,
                        description: event.clue.description,
                        location: event.location,
                        act: gameState.currentAct,
                        timestamp: Date.now()
                    });
                }
            }

            processSuspiciousBehavior(event) {
                if (!event.suspect) return;
                
                this.addSuspicion(event.suspect.id, 'suspicious_behavior', 0.3, event.reason || 'Acting strange');
            }

            addSuspicion(suspectId, reason, confidence, evidence) {
                if (!this.suspicions.has(suspectId)) {
                    this.suspicions.set(suspectId, {
                        level: 0,
                        reasons: [],
                        evidence: [],
                        timestamp: Date.now()
                    });
                }
                
                const suspicion = this.suspicions.get(suspectId);
                suspicion.reasons.push(reason);
                suspicion.evidence.push(evidence);
                suspicion.level = Math.min(1.0, suspicion.level + confidence);
                suspicion.timestamp = Date.now();
            }

            getSuspicionLevel(suspectId) {
                const suspicion = this.suspicions.get(suspectId);
                return suspicion ? suspicion.level : 0;
            }

            getMostSuspected() {
                let maxSuspicion = 0;
                let mostSuspected = null;
                
                this.suspicions.forEach((data, suspectId) => {
                    if (data.level > maxSuspicion) {
                        maxSuspicion = data.level;
                        mostSuspected = suspectId;
                    }
                });
                
                return mostSuspected ? { id: mostSuspected, level: maxSuspicion } : null;
            }

            updateTrust(characterId, change) {
                const currentTrust = this.trust.get(characterId) || 0.5;
                const newTrust = Math.max(0, Math.min(1, currentTrust + change));
                this.trust.set(characterId, newTrust);
                
                // Update allies based on trust
                if (newTrust >= 0.7) {
                    this.allies.add(characterId);
                } else if (newTrust <= 0.3) {
                    this.allies.delete(characterId);
                }
            }

            getTrustLevel(characterId) {
                return this.trust.get(characterId) || 0.5;
            }

            shareCluesWith(otherCharacter) {
                // Share some clues with trusted allies
                if (this.getTrustLevel(otherCharacter.id) >= 0.7) {
                    return this.clues.slice(-2); // Share last 2 clues
                }
                return [];
            }
            
            addClue(clue) {
                // Add a clue to this character's memory
                this.clues.push({
                    ...clue,
                    timestamp: clue.timestamp || Date.now(),
                    act: clue.act || gameState.currentAct
                });
                
                // Limit to last 10 clues to prevent memory bloat
                if (this.clues.length > 10) {
                    this.clues = this.clues.slice(-10);
                }
            }
        }

        // Campy Horror Dialogue System - All 20 Archetypes
        const campyHorrorDialogue = {
            'The Final Girl': {
                death_reactions: [
                    "No! This ends NOW! I won't let anyone else die!",
                    "I should have seen this coming... I should have protected them!",
                    "That's it! We're getting out of here RIGHT NOW!",
                    "I'm not losing anyone else tonight!",
                    "Why does this always happen to us?!",
                    "We need to stick together - it's our only chance!",
                    "I'm going to find this killer and end this nightmare!",
                    "They picked the wrong group to terrorize!",
                    "Everyone who's died tonight... their deaths won't be in vain!",
                    "I swear on my life, I'll get us out of here alive!",
                    "This psycho just made the biggest mistake of their life!",
                    "I've watched enough horror movies to know how this ends!",
                    "No more running. No more hiding. Time to fight back!",
                    "They want to play games? Let's play!"
                ],
                attack_reactions: [
                    "Get away from them, you psycho!",
                    "Not on my watch!",
                    "I'll fight you to the death!",
                    "You picked the wrong girl to mess with!",
                    "This stops here and now!",
                    "Touch them and you're dead!",
                    "Over my dead body!",
                    "I've had enough of your sick games!",
                    "You want a fight? You got one!",
                    "I'm done being scared of you!",
                    "Time to show you what real strength looks like!",
                    "You messed with the wrong survivor!"
                ],
                suspicious_moments: [
                    "Something's not right about you...",
                    "I've got my eye on you.",
                    "Don't think I haven't noticed your behavior.",
                    "You're hiding something, aren't you?",
                    "I don't trust you as far as I can throw you.",
                    "Your story doesn't add up.",
                    "Why are you always conveniently absent when things happen?",
                    "I'm watching you very carefully from now on.",
                    "You're acting way too calm for someone who should be terrified.",
                    "Something about your alibis keeps bothering me.",
                    "You know more than you're letting on, don't you?"
                ],
                terrified: [
                    "This is like a nightmare I can't wake up from!",
                    "How is this real?! How is any of this REAL?!",
                    "I just want to go home... I just want this to be over!",
                    "Please tell me this is some sick joke!",
                    "I can't... I can't handle much more of this...",
                    "Every shadow could be hiding death itself!",
                    "I keep thinking I hear footsteps behind me!",
                    "What if we never make it out of here alive?",
                    "My heart won't stop pounding in my chest!",
                    "I feel like I'm losing my mind!",
                    "Every sound makes me jump out of my skin!",
                    "This house feels like a death trap!"
                ]
            },
            'The Flirt': {
                death_reactions: [
                    "OMG, this is SO not cute! I'm having a total breakdown!",
                    "My mascara is RUINED! And so is my night!",
                    "This is literally the worst date EVER!",
                    "I broke a nail running! This killer owes me a manicure!",
                    "I didn't dress up to die tonight!",
                    "Can we please focus on MY survival here?!"
                ],
                attack_reactions: [
                    "Don't you DARE mess up my hair!",
                    "These shoes cost more than your car!",
                    "Security! SECURITY! Where's security?!",
                    "I am NOT dying in this outfit!",
                    "You are SO getting a bad Yelp review!"
                ],
                suspicious_moments: [
                    "Ew, you're giving me major creeper vibes.",
                    "Are you, like, hitting on me or planning to kill me?",
                    "Your energy is totally off and not in a good way.",
                    "I've dated psychos before, but you're next level.",
                    "Something about you screams 'stay away.'"
                ],
                terrified: [
                    "This is NOT the kind of attention I wanted!",
                    "I'm too pretty to die! Way too pretty!",
                    "Can we call my daddy? He'll fix this!",
                    "I'm having the worst hair day AND I'm gonna die!",
                    "This is going to ruin my Instagram aesthetic!"
                ]
            },
            'The Jock': {
                death_reactions: [
                    "That's it! I'm gonna pound this freak into the ground!",
                    "Nobody hurts my team! NOBODY!",
                    "I'll bench press this killer's corpse!",
                    "Time to show this punk what real strength looks like!",
                    "Coach always said protect your teammates!",
                    "Game over, psycho! GAME OVER!"
                ],
                attack_reactions: [
                    "Come at me, bro! I DARE you!",
                    "Is that all you got?! My grandma hits harder!",
                    "I eat punks like you for breakfast!",
                    "You just picked a fight with the wrong guy!",
                    "Time to take you to school!"
                ],
                suspicious_moments: [
                    "I don't like the cut of your jib, pal.",
                    "You seem like the type who gets stuffed in lockers.",
                    "Something's off about you, and I don't like it.",
                    "I've got my eye on you, weirdo.",
                    "You're acting sketchy, and I don't trust sketchy."
                ],
                terrified: [
                    "This is way worse than losing the championship!",
                    "I can't protect everyone... I'm failing them!",
                    "Coach never prepared us for THIS!",
                    "I'm supposed to be the strong one!",
                    "Even my muscles can't save us from this!"
                ]
            },
            'The Nerd': {
                death_reactions: [
                    "According to my calculations, this shouldn't be happening!",
                    "The statistical probability of survival is dropping rapidly!",
                    "I need more data! I can't solve this without more data!",
                    "This defies all logical explanation!",
                    "Error 404: Rational thinking not found!",
                    "My algorithms didn't account for this variable!"
                ],
                attack_reactions: [
                    "Fascinating! The killer shows signs of advanced psychological deterioration!",
                    "This is highly illogical behavior!",
                    "Your methodology is flawed and inefficient!",
                    "I'll document this for my future thesis!",
                    "Scientifically speaking, you're completely insane!"
                ],
                suspicious_moments: [
                    "Your behavioral patterns indicate deception.",
                    "I've been running probability analyses on everyone here.",
                    "The evidence strongly suggests you're the perpetrator.",
                    "My observations have led me to one conclusion...",
                    "The data doesn't lie, and it all points to you."
                ],
                terrified: [
                    "This is outside my area of expertise!",
                    "I need to recalibrate my entire worldview!",
                    "Science can't explain this madness!",
                    "My brain is experiencing a fatal error!",
                    "Logic has completely abandoned me!"
                ]
            },
            'The Stoner': {
                death_reactions: [
                    "Dude... that's some seriously bad karma right there...",
                    "This is, like, the ultimate buzzkill, man.",
                    "The universe is seriously out of balance tonight.",
                    "That's some heavy stuff... really heavy.",
                    "I'm getting some seriously dark energy here.",
                    "This is messing with my chakras in a major way."
                ],
                attack_reactions: [
                    "Whoa, man! Can't we all just get along?",
                    "Violence is never the answer, dude!",
                    "This is seriously harsh my mellow!",
                    "I thought you were cool, but you're totally not cool!",
                    "Bad vibes, man! REALLY bad vibes!"
                ],
                suspicious_moments: [
                    "You're giving off some weird energy, dude.",
                    "My third eye is telling me you're trouble.",
                    "Something about your aura is totally off.",
                    "I'm sensing some dark intentions from you.",
                    "The spirits are warning me about you, man."
                ],
                terrified: [
                    "This is like the worst trip ever, and I'm not even high!",
                    "The cosmic balance is totally screwed!",
                    "I need to find my center... where's my center?!",
                    "This is seriously messing with my zen!",
                    "Even my meditation techniques aren't working!"
                ]
            },
            'The Rich Girl': {
                death_reactions: [
                    "This is UNACCEPTABLE! I demand to speak to your manager!",
                    "Do you know who my father is?! He'll SUE everyone!",
                    "I'm calling my lawyer! And my bodyguard! And my daddy!",
                    "This wouldn't happen at the country club!",
                    "I'm not supposed to be here! This is for poor people!",
                    "My trust fund does NOT cover this kind of trauma!"
                ],
                attack_reactions: [
                    "Don't you dare touch me! I'm worth millions!",
                    "Security! Where is my personal security detail?!",
                    "I'll have you arrested! My father owns the police!",
                    "You can't do this to me! I'm IMPORTANT!",
                    "This dress cost more than your house!"
                ],
                suspicious_moments: [
                    "You look like you shop at discount stores.",
                    "I don't associate with people like you.",
                    "Your social credit score must be terrible.",
                    "You probably can't even afford to be suspicious.",
                    "I bet you're jealous of my lifestyle."
                ],
                terrified: [
                    "Money can't buy me out of this nightmare!",
                    "I've never been this powerless in my LIFE!",
                    "Why isn't my privilege protecting me?!",
                    "This is worse than when daddy cut my allowance!",
                    "I'm not equipped to handle poor people problems!"
                ]
            },
            'The Bad Boy': {
                death_reactions: [
                    "That's it. This freak just signed their death warrant.",
                    "I've seen some messed up stuff, but this is next level.",
                    "Time to handle this the hard way.",
                    "I'm gonna make this killer regret the day they were born.",
                    "Nobody kills my people. NOBODY.",
                    "This punk just picked a war with the wrong guy."
                ],
                attack_reactions: [
                    "You think you're tough? Let me show you tough!",
                    "I've been in prison fights scarier than you!",
                    "Come on then! Let's dance!",
                    "I eat punks like you for breakfast!",
                    "You just made the biggest mistake of your short life!"
                ],
                suspicious_moments: [
                    "I can smell trouble on you from a mile away.",
                    "Your type always thinks they're smarter than they are.",
                    "I've dealt with scum like you before.",
                    "You got that guilty look written all over your face.",
                    "I know a snake when I see one."
                ],
                terrified: [
                    "This is worse than anything I faced on the streets...",
                    "Even the toughest cons would run from this!",
                    "I thought I was the scariest thing in the room...",
                    "My street cred can't protect me from this!",
                    "For the first time in my life... I'm actually scared."
                ]
            },
            'The Innocent': {
                death_reactions: [
                    "Why would someone do something so horrible?!",
                    "I don't understand! People are supposed to be good!",
                    "This can't be real! Please tell me this is a nightmare!",
                    "I just want everyone to be safe and happy!",
                    "There has to be good left in the world... there has to be!",
                    "Maybe if we just talk to them, we can work this out?"
                ],
                attack_reactions: [
                    "Please don't hurt me! I've never hurt anyone!",
                    "I forgive you! Whatever made you this way, I forgive you!",
                    "You don't have to do this! You can choose to be good!",
                    "There's still time to stop! You can still be saved!",
                    "I believe there's good in everyone... even you!"
                ],
                suspicious_moments: [
                    "I want to trust you, but something feels wrong...",
                    "You seem sad... are you okay?",
                    "Maybe you're just misunderstood?",
                    "I hope I'm wrong about you...",
                    "Please tell me you're one of the good guys..."
                ],
                terrified: [
                    "I don't want to believe people can be this evil!",
                    "My whole worldview is crumbling!",
                    "How can there be so much darkness in the world?",
                    "I just want to go home to my family!",
                    "Please let there be some hope left... please..."
                ]
            },
            'The Outcast': {
                death_reactions: [
                    "I TOLD you something was wrong! But did anyone listen? NO!",
                    "This is exactly what I predicted would happen!",
                    "I tried to warn everyone, but you all thought I was crazy!",
                    "I've been preparing for this my whole life!",
                    "Finally! Someone who understands true darkness!",
                    "I knew this day would come... I've been ready."
                ],
                attack_reactions: [
                    "You think darkness scares me? I AM the darkness!",
                    "I've been living in nightmares my whole life!",
                    "You picked the wrong weirdo to mess with!",
                    "I know things about pain you couldn't imagine!",
                    "Death has been my only friend for years!"
                ],
                suspicious_moments: [
                    "I see the evil in your soul... it calls to mine.",
                    "You can't hide your true nature from me.",
                    "I recognize a kindred spirit when I see one.",
                    "The shadows whisper secrets about you.",
                    "Your darkness is almost as deep as mine... almost."
                ],
                terrified: [
                    "Even I didn't expect it to be this bad...",
                    "This is beyond anything I imagined in my darkest dreams!",
                    "Maybe being alone forever wasn't the worst fate...",
                    "I thought I knew what horror looked like!",
                    "I've stared into the abyss... but this stares back!"
                ]
            },
            'The Party Girl': {
                death_reactions: [
                    "This is NOT the kind of party I signed up for!",
                    "Someone seriously needs to change the music!",
                    "This party has officially jumped the shark!",
                    "Can we please get back to having FUN?!",
                    "This is worse than a dry wedding!",
                    "I've been to some wild parties, but this is INSANE!"
                ],
                attack_reactions: [
                    "You are seriously ruining the vibe!",
                    "This is the worst party crasher EVER!",
                    "Security! We need better security at this party!",
                    "You're not on the guest list, psycho!",
                    "I'm giving this party zero stars!"
                ],
                suspicious_moments: [
                    "You're being a real party pooper.",
                    "Are you always this much of a downer?",
                    "You're giving off serious bad party guest vibes.",
                    "I bet you're the type who leaves early.",
                    "Something about you screams 'doesn't know how to have fun.'"
                ],
                terrified: [
                    "This is the WORST party ever! One star review!",
                    "I just wanted to dance and have a good time!",
                    "Why can't people just party responsibly?!",
                    "This is going to ruin my social media!",
                    "I'm never attending another house party again!"
                ]
            },
            'The Skeptic': {
                death_reactions: [
                    "There's a perfectly rational explanation for this!",
                    "This has to be some kind of elaborate hoax!",
                    "Someone's using psychological manipulation!",
                    "I refuse to believe in supernatural nonsense!",
                    "This is just advanced special effects!",
                    "Science will explain everything once we investigate!"
                ],
                attack_reactions: [
                    "Your tricks won't work on someone with a logical mind!",
                    "I see through your cheap parlor tricks!",
                    "This is all smoke and mirrors!",
                    "You're just a human with psychological problems!",
                    "I'll expose your methods to everyone!"
                ],
                suspicious_moments: [
                    "I'm analyzing your behavior patterns.",
                    "Your story has several logical inconsistencies.",
                    "The evidence suggests you're hiding something.",
                    "I'll apply scientific method to figure you out.",
                    "Your claims don't hold up under scrutiny."
                ],
                terrified: [
                    "This challenges everything I believe about reality!",
                    "How can I explain this with science?!",
                    "My rational worldview is completely shattered!",
                    "There has to be a logical explanation... HAS TO BE!",
                    "I'm having a crisis of faith in reason itself!"
                ]
            },
            'The Hero': {
                death_reactions: [
                    "I swear on my honor, I'll stop this monster!",
                    "No more innocent blood will be spilled tonight!",
                    "Their sacrifice will not be in vain!",
                    "I'll protect everyone else with my life!",
                    "Evil will NOT triumph while I still breathe!",
                    "This ends here and now!"
                ],
                attack_reactions: [
                    "You face a true champion of justice!",
                    "I'll stop you with the power of righteousness!",
                    "Evil cannot defeat pure heroism!",
                    "For truth, justice, and the innocent!",
                    "Your reign of terror ends with me!"
                ],
                suspicious_moments: [
                    "My heroic instincts are warning me about you.",
                    "A true hero can sense evil in their presence.",
                    "Justice will reveal your true nature.",
                    "I'll be watching you very carefully.",
                    "My duty is to protect others from people like you."
                ],
                terrified: [
                    "I've failed as a protector... how can I live with this?",
                    "Even heroes have limits... and I've found mine.",
                    "I'm supposed to be the one saving everyone!",
                    "How can evil be this powerful?!",
                    "I need to find my courage... everyone's counting on me!"
                ]
            },
            'The Coward': {
                death_reactions: [
                    "I'm getting OUT of here! Every man for himself!",
                    "NOPE! Not dealing with this! I'm DONE!",
                    "I didn't sign up for a death sentence!",
                    "Self-preservation mode: ACTIVATED!",
                    "I'm too young and too scared to die!",
                    "Someone else can be the hero! I'm RUNNING!"
                ],
                attack_reactions: [
                    "Please don't kill me! I'll do anything!",
                    "I'm not brave! I'm a total coward! Please!",
                    "I promise I won't tell anyone anything!",
                    "I'll hide and never bother you again!",
                    "There are braver people here! Pick them!"
                ],
                suspicious_moments: [
                    "I don't trust ANYONE right now!",
                    "Everyone's a potential killer to me!",
                    "I'm suspicious of literally everyone!",
                    "You could be the murderer! Anyone could be!",
                    "I'm not taking any chances with ANYONE!"
                ],
                terrified: [
                    "I can't handle this! I CAN'T HANDLE THIS!",
                    "Why did I leave my house?! Why?!",
                    "I should have stayed home with my cats!",
                    "This is exactly why I avoid social situations!",
                    "I'm having a full panic attack right now!"
                ]
            },
            'The Goth': {
                death_reactions: [
                    "Death comes for us all... some sooner than others.",
                    "Ah, the sweet embrace of eternal darkness.",
                    "Finally, some real entertainment in this boring world.",
                    "Death is just another door to a darker room.",
                    "How beautifully macabre... like poetry in motion.",
                    "The darkness has finally revealed its true face."
                ],
                attack_reactions: [
                    "You think death frightens me? I've been flirting with it for years.",
                    "How deliciously twisted... I almost admire your style.",
                    "Pain is just another form of dark poetry.",
                    "You're not nearly as dark as you think you are.",
                    "I've seen deeper darkness in my own soul."
                ],
                suspicious_moments: [
                    "I can smell the decay of your soul from here.",
                    "Your aura reeks of death and corruption.",
                    "The shadows whisper dark secrets about you.",
                    "I recognize a fellow creature of darkness.",
                    "Your inner demons are showing."
                ],
                terrified: [
                    "This darkness is too real... even for me!",
                    "I thought I understood the void... but this IS the void!",
                    "My romanticized view of death is crumbling!",
                    "Real horror makes my poetry look like children's songs!",
                    "The abyss isn't as romantic as I thought!"
                ]
            },
            'The Tomboy': {
                death_reactions: [
                    "That's it! I'm done playing defense!",
                    "Time to show this creep what a real fight looks like!",
                    "I didn't climb trees and scrape knees to die like this!",
                    "Let's see how tough they are against someone who fights back!",
                    "I've been in tougher scraps in middle school!",
                    "Nobody messes with my crew! NOBODY!"
                ],
                attack_reactions: [
                    "Is that all you got?! My little brother hits harder!",
                    "You picked the wrong girl to mess with!",
                    "I've been waiting for a good fight all night!",
                    "Come on! Let's see what you're really made of!",
                    "Time to show you how we handle bullies!"
                ],
                suspicious_moments: [
                    "Something about you rubs me the wrong way.",
                    "I don't like your attitude, pal.",
                    "You're acting shady, and I don't like shady.",
                    "My gut says you're trouble.",
                    "I've got my eye on you, weirdo."
                ],
                terrified: [
                    "I'm tough, but this is beyond anything I've faced!",
                    "All my scrapping experience means nothing here!",
                    "I thought I was ready for anything... I was wrong!",
                    "Being tough doesn't help when the world goes insane!",
                    "I need to find my inner strength... fast!"
                ]
            },
            'The Drama Queen': {
                death_reactions: [
                    "This is the WORST tragedy in the HISTORY of tragedies!",
                    "I am literally having the most DRAMATIC moment of my LIFE!",
                    "This is like Shakespeare's WORST nightmare!",
                    "I can't BELIEVE this is happening to ME!",
                    "This is more dramatic than ALL my favorite soap operas!",
                    "I am the STAR of my own horror movie!"
                ],
                attack_reactions: [
                    "You're ruining my MOMENT! This is MY scene!",
                    "I refuse to be a supporting character in my own death!",
                    "This is NOT how my story is supposed to end!",
                    "I demand better dialogue if I'm going to die!",
                    "At least make my death MEMORABLE and BEAUTIFUL!"
                ],
                suspicious_moments: [
                    "You're giving me MAJOR villain vibes!",
                    "I can sense the DRAMA radiating from you!",
                    "You're obviously the antagonist in this story!",
                    "Your suspicious behavior is TOTALLY obvious!",
                    "I've seen enough movies to know YOU'RE the killer!"
                ],
                terrified: [
                    "This is NOT the starring role I wanted!",
                    "I'm too BEAUTIFUL to die in a B-movie!",
                    "My agent never prepared me for THIS kind of role!",
                    "This better have a HAPPY ending or I want a refund!",
                    "I demand to speak to the director of this nightmare!"
                ]
            },
            'The Boyfriend': {
                death_reactions: [
                    "I swear I'll protect her with my last breath!",
                    "Nobody touches my girl! NOBODY!",
                    "If anything happens to her, I'll kill you myself!",
                    "She's everything to me! I won't let you hurt her!",
                    "Our love will survive this nightmare!",
                    "I'd rather die than let her get hurt!"
                ],
                attack_reactions: [
                    "Stay away from my girlfriend!",
                    "You want to get to her? You go through ME first!",
                    "Real men protect the people they love!",
                    "I'll fight you to the death for her!",
                    "Love gives me strength you can't imagine!"
                ],
                suspicious_moments: [
                    "If you hurt her, I'll end you.",
                    "I don't like how you look at my girl.",
                    "Something about you screams 'stay away from my girlfriend.'",
                    "I'm watching you, and I don't like what I see.",
                    "You better keep your distance from her."
                ],
                terrified: [
                    "I have to find her! Where is she?!",
                    "I can't protect her if I can't find her!",
                    "Please let her be safe... please let her be okay!",
                    "I'm failing as her boyfriend!",
                    "Love should be enough to save us both!"
                ]
            },
            'The Best Friend': {
                death_reactions: [
                    "We promised we'd always be there for each other!",
                    "Best friends stick together through EVERYTHING!",
                    "I won't let anyone hurt my bestie!",
                    "We've been through so much together!",
                    "Friendship is stronger than fear!",
                    "BFFs forever means FOREVER!"
                ],
                attack_reactions: [
                    "Don't you DARE touch my best friend!",
                    "Friendship power activate!",
                    "You mess with her, you mess with me!",
                    "Best friends defend each other!",
                    "Our friendship will defeat you!"
                ],
                suspicious_moments: [
                    "I don't trust you around my best friend.",
                    "My bestie deserves better people in her life.",
                    "Something about you threatens our friendship.",
                    "I can sense when someone's bad for my friend.",
                    "Best friend intuition is telling me to watch you."
                ],
                terrified: [
                    "I can't lose my best friend!",
                    "She's like a sister to me!",
                    "How can I live without my other half?",
                    "Our friendship is all I have!",
                    "Please don't let anything happen to her!"
                ]
            },
            'The Reporter': {
                death_reactions: [
                    "This is the story of the century!",
                    "I need to document everything for posterity!",
                    "The world NEEDS to know what happened here!",
                    "This will win me a Pulitzer... if I survive!",
                    "My journalistic duty demands I get the truth!",
                    "I'm not just a witness, I'm a recorder of history!"
                ],
                attack_reactions: [
                    "You can kill me, but you can't kill the truth!",
                    "The story will get out no matter what!",
                    "I've interviewed war criminals scarier than you!",
                    "Freedom of the press means something!",
                    "This is going straight to the front page!"
                ],
                suspicious_moments: [
                    "I've interviewed enough criminals to spot one.",
                    "My investigative instincts are screaming about you.",
                    "I smell a story, and it reeks of guilt.",
                    "Years of journalism have taught me to read people.",
                    "You've got that 'guilty as sin' look down pat."
                ],
                terrified: [
                    "This story is too big for just one reporter!",
                    "I signed up to report news, not become it!",
                    "How do I file a story if I don't survive?",
                    "The truth is scarier than any fiction!",
                    "My press badge isn't protecting me from this!"
                ]
            },
            'The Horror Fanatic': {
                death_reactions: [
                    "This is EXACTLY like in 'Blood Camp Massacre 3'!",
                    "I've seen this movie! I know how it ends!",
                    "Classic slasher movie setup! Textbook execution!",
                    "The kill count is rising right on schedule!",
                    "This is better than any movie I've ever seen!",
                    "Real horror is so much more intense than film!"
                ],
                attack_reactions: [
                    "Wait! You're breaking the genre conventions!",
                    "That's not how killers are supposed to behave!",
                    "I know all the horror movie rules!",
                    "You can't kill the horror expert! That's against the rules!",
                    "This doesn't follow proper slasher methodology!"
                ],
                suspicious_moments: [
                    "You fit the killer profile perfectly!",
                    "I've seen enough horror movies to spot the murderer!",
                    "Classic red herring behavior, but I'm not fooled!",
                    "Your MO matches seventeen different slasher films!",
                    "I know a final boss when I see one!"
                ],
                terrified: [
                    "This doesn't follow ANY of the established rules!",
                    "Real horror is nothing like the movies!",
                    "All my genre knowledge is useless!",
                    "I thought I was prepared for this!",
                    "The movies never showed how terrifying this really is!"
                ]
            }
        };

        // Enhanced dialogue generation
        function generateCampyDialogue(character, situation, context = {}) {
            // Check for returning survivor special dialogue
            if (character.isReturning && character.legacyMemory) {
                const legacyDialogue = generateLegacyDialogue(character, situation);
                if (legacyDialogue) {
                    return legacyDialogue;
                }
            }
            
            const archetype = character.archetype.name;
            const dialogueSet = campyHorrorDialogue[archetype];
            
            if (!dialogueSet) {
                return getGenericCampyDialogue(situation, character.name);
            }

            let emotionalState = 'terrified';
            if (character.memory) {
                emotionalState = character.memory.emotionalState;
            }

            let dialogueArray;
            switch(situation) {
                case 'death':
                    dialogueArray = dialogueSet.death_reactions;
                    break;
                case 'attack':
                    dialogueArray = dialogueSet.attack_reactions;
                    break;
                case 'suspicious':
                    dialogueArray = dialogueSet.suspicious_moments;
                    break;
                case 'terrified':
                    dialogueArray = dialogueSet.terrified;
                    break;
                default:
                    dialogueArray = dialogueSet.terrified;
            }

            const selectedDialogue = dialogueArray[Math.floor(Math.random() * dialogueArray.length)];
            
            // Add relationship context if available
            if (context.relationshipTarget) {
                const relationship = getRelationship(character, context.relationshipTarget);
                if (relationship) {
                    return modifyDialogueForRelationship(selectedDialogue, relationship, character, context.relationshipTarget, character.name);
                }
            }

            return `"${selectedDialogue}" - ${character.name}`;
        }
        
        function generateLegacyDialogue(character, situation) {
            const legacy = character.legacyMemory;
            const movieCount = legacy.previousMovieCount;
            
            // 40% chance to use legacy dialogue for returning survivors
            if (Math.random() > 0.4) return null;
            
            const legacyDialogueSet = {
                death: [
                    `"Not again... please not again! I can't go through this a second time!"`,
                    `"This is exactly how it started last time... we need to get out NOW!"`,
                    `"I survived ${movieCount} horror movie${movieCount > 1 ? 's' : ''} and I'll survive this one too!"`,
                    `"I know how this ends. We need to be smarter this time."`,
                    `"The nightmares were just starting to fade... now they're back."`,
                    `"I should have known this wasn't over. It's never over."`,
                    `"Last time I lost everyone I cared about. I won't let that happen again!"`
                ],
                attack: [
                    `"I've been through this before! You picked the wrong survivor!"`,
                    `"I know all your tricks! I survived worse than you!"`,
                    `"This is like a sick déjà vu! But I'm ready this time!"`,
                    `"I didn't survive last time to die here!"`,
                    `"You want to mess with a veteran survivor? Bring it on!"`
                ],
                suspicious: [
                    `"I've seen this behavior before... you're the killer, aren't you?"`,
                    `"My PTSD might be bad, but my killer instincts are sharp."`,
                    `"Last movie taught me to trust my gut... and my gut says you're dangerous."`,
                    `"I know what a killer looks like. I've stared one in the face before."`,
                    `"The pattern is the same as last time. You're not fooling me."`
                ],
                terrified: [
                    `"The flashbacks are getting worse... this is exactly like before!"`,
                    `"I thought the therapy was working... but here we are again!"`,
                    `"How many times do I have to live through this nightmare?!"`,
                    `"I can't tell what's real and what's a flashback anymore!"`,
                    `"They said I was safe now... they LIED to me!"`,
                    `"My therapist didn't prepare me for a sequel!"`,
                    `"I barely made it out alive last time... what are my odds now?"`
                ]
            };
            
            const dialogueArray = legacyDialogueSet[situation] || legacyDialogueSet.terrified;
            const selectedDialogue = dialogueArray[Math.floor(Math.random() * dialogueArray.length)];
            
            return `${selectedDialogue} - ${character.name}, haunted by the past`;
        }

        function modifyDialogueForRelationship(dialogue, relationship, speaker, target, speakerName) {
            const relType = relationship.type;
            const targetName = target.name;
            
            switch(relType) {
                case relationshipTypes.ROMANTIC:
                    if (dialogue.includes('her') || dialogue.includes('girlfriend')) {
                        return `"${dialogue}" - ${speakerName}`;
                    }
                    return `"${dialogue.replace(/you|them|they/gi, `${targetName}, my love`)}" - ${speakerName}`;
                case relationshipTypes.BEST_FRIENDS:
                    return `"${dialogue.replace(/you|them|they/gi, `${targetName}, bestie`)}" - ${speakerName}`;
                case relationshipTypes.FAMILY:
                    return `"${dialogue.replace(/you|them|they/gi, `${targetName}, my family`)}" - ${speakerName}`;
                case relationshipTypes.ENEMIES:
                    return `"${dialogue.replace(/you|them|they/gi, `that jerk ${targetName}`)}" - ${speakerName}`;
                case relationshipTypes.EX_LOVERS:
                    return `"${dialogue.replace(/you|them|they/gi, `${targetName}... my ex`)}" - ${speakerName}`;
                default:
                    return `"${dialogue}" - ${speakerName}`;
            }
        }

        function getGenericCampyDialogue(situation, characterName) {
            const generic = {
                death: [
                    "Oh no! This is like a bad horror movie!",
                    "Why does this always happen to us?!",
                    "I didn't sign up for this nightmare!",
                    "This is worse than my worst fears!"
                ],
                attack: [
                    "Help me! Somebody help me!",
                    "Get away from me, you psycho!",
                    "This can't be happening!",
                    "I'm too young to die!"
                ],
                suspicious: [
                    "Something's not right about you...",
                    "I've got a bad feeling about this.",
                    "You're acting really weird.",
                    "I don't trust you one bit."
                ],
                terrified: [
                    "This is the worst night of my life!",
                    "I just want to go home!",
                    "Please let this be a nightmare!",
                    "How is this real?!"
                ]
            };
            
            const options = generic[situation] || generic.terrified;
            const selectedDialogue = options[Math.floor(Math.random() * options.length)];
            return `"${selectedDialogue}" - ${characterName}`;
        }

        // Initialize character memories when characters are created
        function initializeCharacterMemories() {
            gameState.characters.forEach(character => {
                if (!character.memory) {
                    character.memory = new CharacterMemory(character.id);
                }
            });
        }

        // Generate random character reactions to events
        function addRandomCharacterReactions(eventType, numReactions = 2) {
            // Don't add reactions if movie is complete
            if (gameState.movieComplete) return;
            
            const aliveCharacters = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            if (aliveCharacters.length === 0) return;

            // Shuffle and pick random characters to react
            const shuffled = [...aliveCharacters].sort(() => 0.5 - Math.random());
            const reactors = shuffled.slice(0, Math.min(numReactions, aliveCharacters.length));

            reactors.forEach((character, index) => {
                setTimeout(() => {
                    // Double-check movie isn't complete when timeout executes
                    if (gameState.movieComplete) return;
                    
                    // Update character's memory
                    if (character.memory) {
                        character.memory.addExperience({ type: eventType });
                    }

                    // Generate dialogue based on situation
                    let situation = eventType;
                    if (character.memory && character.memory.witnessedDeaths.length >= 2) {
                        situation = 'terrified';
                    }

                    const dialogue = generateCampyDialogue(character, situation);
                    addEvent('dialogue', dialogue);
                }, index * 800); // Stagger reactions
            });
        }

        // Enhanced story progression with character memories
        function addCharacterMemoriesToEvent(eventType, specificCharacter = null) {
            if (specificCharacter && specificCharacter.memory) {
                specificCharacter.memory.addExperience({ type: eventType });
            } else {
                // Add to all living characters' memories
                gameState.characters.forEach(character => {
                    if (character.status === 'Alive' && character.memory) {
                        character.memory.addExperience({ type: eventType });
                    }
                });
            }
        }


        // Audio System
        let audioContext;
        let audioSettings = {
            ambient: true,
            sfx: true,
            music: true,
            masterVolume: 0.3
        };


        // Audio Widget Drag and Minimize System
        let audioWidgetState = {
            isMinimized: false,
            isDragging: false,
            dragOffset: { x: 0, y: 0 },
            position: { x: 20, y: 20 } // Default position from right and top
        };


        function initAudioWidget() {
            const widget = document.getElementById('audio-widget');
            const dragHandle = document.getElementById('audio-drag-handle');
            
            if (!widget || !dragHandle) return;
            
            // Set initial position
            widget.style.right = audioWidgetState.position.x + 'px';
            widget.style.top = audioWidgetState.position.y + 'px';
            widget.style.left = 'auto';
            widget.style.bottom = 'auto';
            
            // Add drag functionality
            dragHandle.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', stopDrag);
            
            // Touch support for mobile
            dragHandle.addEventListener('touchstart', startDragTouch, { passive: false });
            document.addEventListener('touchmove', dragTouch, { passive: false });
            document.addEventListener('touchend', stopDrag);
        }


        function startDrag(e) {
            audioWidgetState.isDragging = true;
            const widget = document.getElementById('audio-widget');
            const rect = widget.getBoundingClientRect();
            
            audioWidgetState.dragOffset.x = e.clientX - rect.left;
            audioWidgetState.dragOffset.y = e.clientY - rect.top;
            
            widget.classList.add('dragging');
            e.preventDefault();
        }


        function startDragTouch(e) {
            const touch = e.touches[0];
            audioWidgetState.isDragging = true;
            const widget = document.getElementById('audio-widget');
            const rect = widget.getBoundingClientRect();
            
            audioWidgetState.dragOffset.x = touch.clientX - rect.left;
            audioWidgetState.dragOffset.y = touch.clientY - rect.top;
            
            widget.classList.add('dragging');
            e.preventDefault();
        }


        function drag(e) {
            if (!audioWidgetState.isDragging) return;
            
            const widget = document.getElementById('audio-widget');
            const x = e.clientX - audioWidgetState.dragOffset.x;
            const y = e.clientY - audioWidgetState.dragOffset.y;
            
            updateWidgetPosition(widget, x, y);
            e.preventDefault();
        }


        function dragTouch(e) {
            if (!audioWidgetState.isDragging) return;
            
            const touch = e.touches[0];
            const widget = document.getElementById('audio-widget');
            const x = touch.clientX - audioWidgetState.dragOffset.x;
            const y = touch.clientY - audioWidgetState.dragOffset.y;
            
            updateWidgetPosition(widget, x, y);
            e.preventDefault();
        }


        function updateWidgetPosition(widget, x, y) {
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const widgetRect = widget.getBoundingClientRect();
            
            // Keep widget within screen bounds
            const minX = 0;
            const maxX = windowWidth - widgetRect.width;
            const minY = 0;
            const maxY = windowHeight - widgetRect.height;
            
            const clampedX = Math.max(minX, Math.min(maxX, x));
            const clampedY = Math.max(minY, Math.min(maxY, y));
            
            widget.style.left = clampedX + 'px';
            widget.style.top = clampedY + 'px';
            widget.style.right = 'auto';
            widget.style.bottom = 'auto';
            
            // Update position state
            audioWidgetState.position.x = clampedX;
            audioWidgetState.position.y = clampedY;
        }


        function stopDrag() {
            if (!audioWidgetState.isDragging) return;
            
            audioWidgetState.isDragging = false;
            const widget = document.getElementById('audio-widget');
            widget.classList.remove('dragging');
        }


        function toggleAudioWidget() {
            const widget = document.getElementById('audio-widget');
            const minimizeBtn = document.getElementById('minimize-audio');
            const content = document.getElementById('audio-content');
            
            audioWidgetState.isMinimized = !audioWidgetState.isMinimized;
            
            if (audioWidgetState.isMinimized) {
                widget.classList.add('minimizing');
                setTimeout(() => {
                    widget.classList.add('minimized');
                    widget.classList.remove('minimizing');
                }, 150);
                
                minimizeBtn.textContent = '+';
                minimizeBtn.title = 'Expand audio controls';
                createBeep(500, 0.05);
            } else {
                widget.classList.add('maximizing');
                widget.classList.remove('minimized');
                setTimeout(() => {
                    widget.classList.remove('maximizing');
                }, 300);
                
                minimizeBtn.textContent = '−';
                minimizeBtn.title = 'Minimize audio controls';
                createBeep(700, 0.05);
            }
        }


        // Handle window resize to keep widget in bounds
        window.addEventListener('resize', () => {
            if (audioWidgetState.isDragging) return;
            
            const widget = document.getElementById('audio-widget');
            if (!widget) return;
            
            const rect = widget.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            
            // Check if widget is outside bounds and adjust
            if (rect.right > windowWidth || rect.bottom > windowHeight || rect.left < 0 || rect.top < 0) {
                const newX = Math.max(0, Math.min(windowWidth - rect.width, rect.left));
                const newY = Math.max(0, Math.min(windowHeight - rect.height, rect.top));
                
                widget.style.left = newX + 'px';
                widget.style.top = newY + 'px';
                widget.style.right = 'auto';
                widget.style.bottom = 'auto';
                
                audioWidgetState.position.x = newX;
                audioWidgetState.position.y = newY;
            }
        });


        // Simple audio functions for compatibility
        function initAudioSystem() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log('Audio system initialized');
            } catch (error) {
                console.log('Audio not supported');
                audioContext = null;
            }
        }


        function createBeep(frequency, duration) {
            if (!audioContext || !audioSettings.sfx) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = 'sine';
                
                gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(audioSettings.masterVolume * 0.1, audioContext.currentTime + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (error) {
                console.log('Audio playback failed');
            }
        }


        function toggleAmbient() {
            audioSettings.ambient = !audioSettings.ambient;
            const btn = document.getElementById('toggle-ambient');
            btn.classList.toggle('muted', !audioSettings.ambient);
        }


        function toggleSFX() {
            audioSettings.sfx = !audioSettings.sfx;
            const btn = document.getElementById('toggle-sfx');
            btn.classList.toggle('muted', !audioSettings.sfx);
        }


        function toggleMusic() {
            audioSettings.music = !audioSettings.music;
            const btn = document.getElementById('toggle-music');
            btn.classList.toggle('muted', !audioSettings.music);
        }


        function setMasterVolume(value) {
            audioSettings.masterVolume = value / 100;
        }


        // Enhanced visual effects
        function addVisualEffect(element, effectClass, duration = 500) {
            if (!element) return;
            element.classList.add(effectClass);
            setTimeout(() => element.classList.remove(effectClass), duration);
        }


        function createBloodParticles(element, count = 3) {
            if (!element) return;
            for (let i = 0; i < count; i++) {
                const particle = document.createElement('div');
                particle.className = 'blood-particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 1 + 's';
                element.style.position = 'relative';
                element.appendChild(particle);
                setTimeout(() => particle.remove(), 3000);
            }
        }


        function flashScreen(color = 'rgba(255, 0, 0, 0.3)', duration = 200) {
            const flash = document.createElement('div');
            flash.style.cssText = `
                position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
                background: ${color}; z-index: 9999; pointer-events: none;
                animation: flicker ${duration}ms ease-out;
            `;
            document.body.appendChild(flash);
            setTimeout(() => flash.remove(), duration);
        }


        // Enhanced event system
        function addEvent(type, text) {
            gameState.events.push({ type, text, act: gameState.currentAct });
            updateMovieLog();
            
            // Add effects based on event type
            setTimeout(() => {
                const lastEvent = document.querySelector('.event:last-child');
                if (lastEvent) {
                    switch(type) {
                        case 'death':
                            createBeep(150, 0.3);
                            flashScreen('rgba(255, 0, 0, 0.4)', 300);
                            createBloodParticles(lastEvent, 5);
                            addVisualEffect(lastEvent, 'shake-effect');
                            break;
                        case 'attack':
                            createBeep(200, 0.1);
                            flashScreen('rgba(255, 150, 0, 0.3)', 150);
                            addVisualEffect(lastEvent, 'pulse-effect');
                            break;
                        case 'reveal':
                            createBeep(300, 0.5);
                            flashScreen('rgba(138, 43, 226, 0.3)', 400);
                            addVisualEffect(lastEvent, 'pulse-effect', 1000);
                            break;
                        case 'title':
                            createBeep(600, 0.1);
                            addVisualEffect(lastEvent, 'pulse-effect', 1000);
                            break;
                    }
                }
            }, 100);
        }


        function updateMovieLog() {
            const log = document.getElementById('movie-log');
            const latestEvent = gameState.events[gameState.events.length - 1];
            
            const eventDiv = document.createElement('div');
            eventDiv.className = `event ${latestEvent.type}`;
            eventDiv.textContent = latestEvent.text;
            
            log.appendChild(eventDiv);
            log.scrollTop = log.scrollHeight;
            updateCastGridStatus();
        }


        // Setup functions
        function toggleCustomSetting() {
            const settingSelect = document.getElementById('movie-setting');
            const customFields = document.getElementById('custom-setting-fields');
            
            if (settingSelect.value === 'custom') {
                customFields.classList.remove('hidden');
            } else {
                customFields.classList.add('hidden');
            }
        }
        
        function setupCast() {
            try {
                console.log('setupCast function called');
                
                const castSize = parseInt(document.getElementById('cast-size').value);
                const gameMode = document.getElementById('game-mode').value;
                const movieTitle = document.getElementById('movie-title').value || 'Untitled Horror';
                const movieYear = parseInt(document.getElementById('movie-year').value) || new Date().getFullYear();
                const movieSetting = document.getElementById('movie-setting').value;
                
                // Handle custom setting
                let finalSetting = movieSetting;
                if (movieSetting === 'custom') {
                    const customLocation = document.getElementById('custom-location').value;
                    const customAtmosphere = document.getElementById('custom-atmosphere').value;
                    
                    if (!customLocation.trim()) {
                        alert('Please enter a custom location name.');
                        return;
                    }
                    
                    finalSetting = {
                        type: 'custom',
                        location: customLocation.trim(),
                        atmosphere: customAtmosphere.trim() || 'where dark secrets lurk in every shadow'
                    };
                }
                
                console.log('Values:', { castSize, gameMode, movieTitle, movieYear, movieSetting: finalSetting });
                
                gameState.gameMode = gameMode;
                gameState.movieTitle = movieTitle;
                gameState.movieYear = movieYear;
                gameState.movieSetting = finalSetting;
                gameState.isKillerMode = gameMode === 'killer';
                
                // Generate characters
                gameState.characters = [];
                const usedNames = new Set();
                const usedArchetypes = new Set();
                
                for (let i = 0; i < castSize; i++) {
                    let name, archetype;
                    
                    // Get unique name
                    do {
                        name = names[Math.floor(Math.random() * names.length)];
                    } while (usedNames.has(name));
                    usedNames.add(name);
                    
                    // Get unique archetype (allow duplicates if needed)
                    if (archetypes.length >= castSize) {
                        do {
                            archetype = archetypes[Math.floor(Math.random() * archetypes.length)];
                        } while (usedArchetypes.has(archetype.name));
                        usedArchetypes.add(archetype.name);
                    } else {
                        archetype = archetypes[Math.floor(Math.random() * archetypes.length)];
                    }
                    
                    const character = {
                        id: i,
                        name: name,
                        archetype: archetype,
                        stats: { ...archetype.stats },
                        status: 'Alive',
                        actStatuses: { 1: 'Alive', 2: 'Alive', 3: 'Alive' },
                        killedBy: null,
                        deathAct: null,
                        survivalChance: 0, // Will be calculated after memory is added
                        edgic: { 1: 'UTR1', 2: 'UTR1', 3: 'UTR1' },
                        isReturning: false,
                        memory: new CharacterMemory(i)
                    };
                    
                    // Calculate survival chance with memory system
                    character.survivalChance = calculateSurvivalChance(character.stats, character);
                    
                    gameState.characters.push(character);
                }
                
                console.log('Generated characters:', gameState.characters.length);
                
                // Determine killers
                let killerCount = document.getElementById('killer-count').value;
                if (killerCount === 'random') {
                    const rand = Math.random();
                    killerCount = rand < 0.6 ? 1 : rand < 0.9 ? 2 : 3;
                } else {
                    killerCount = parseInt(killerCount);
                }
                
                gameState.killers = [];
                const killerIndices = [];
                while (killerIndices.length < killerCount) {
                    const index = Math.floor(Math.random() * gameState.characters.length);
                    if (!killerIndices.includes(index)) {
                        killerIndices.push(index);
                        gameState.killers.push(gameState.characters[index]);
                    }
                }
                
                console.log('Selected killers:', gameState.killers.length);
                
                displayCastCustomization();
                console.log('setupCast completed successfully');
                
            } catch (error) {
                console.error('Error in setupCast:', error);
                alert('Error creating cast: ' + error.message);
            }
        }


        function calculateSurvivalChance(stats, character = null) {
            const total = stats.survival * 2 + stats.intelligence + stats.athletics + stats.stealth + stats.luck;
            let baseChance = Math.min(90, Math.max(5, total * 1.2));
            
            // Apply memory-based modifications if character has memory
            if (character && character.memory) {
                baseChance += getMemoryBasedSurvivalBonus(character);
            }
            
            return Math.min(95, Math.max(5, baseChance));
        }

        function getMemoryBasedSurvivalBonus(character) {
            const memory = character.memory;
            let bonus = 0;
            
            // Experience bonus (more deaths witnessed = more careful)
            bonus += Math.min(10, memory.survivalExperience * 2);
            
            // Behavior pattern modifiers
            switch(memory.behaviorPattern) {
                case 'cautious': bonus += 5; break;
                case 'aggressive': bonus += 3; break;
                case 'paranoid': bonus += 8; break;
                case 'broken': bonus -= 10; break;
                default: bonus += 0;
            }
            
            // Trust network bonus (allies help survival)
            bonus += Math.min(5, memory.allies.size * 2);
            
            // Trauma penalty (too much trauma hurts decision making)
            bonus -= Math.min(8, memory.traumaLevel);
            
            // Knowledge bonus (knowing killer patterns helps)
            bonus += Math.min(3, memory.knownFacts.size);
            
            return bonus;
        }

        // Investigation and Group Dynamics System
        function generateInvestigationEvent() {
            if (gameState.movieComplete) return;
            
            const aliveCharacters = gameState.characters.filter(c => 
                c.status === 'Alive' && !gameState.killers.includes(c)
            );
            if (aliveCharacters.length < 2) return;

            // Pick investigators based on intelligence and behavior pattern
            let investigators = aliveCharacters
                .filter(c => c.stats.intelligence >= 6 || c.memory.behaviorPattern === 'aggressive')
                .slice(0, 2);
            
            // If no intelligent/aggressive characters, just pick any two alive characters
            if (investigators.length === 0) {
                investigators = aliveCharacters.slice(0, 2);
            }
            
            if (investigators.length === 0) return;

            // Always generate an investigation event to ensure visibility
            addEvent('investigation-start', `🧩 INVESTIGATION: ${investigators.map(i => i.name).join(' and ')} begin investigating the murders...`);
            
            const investigationType = Math.random();
            
            if (investigationType < 0.2) {
                generateSuspicionAccusation(investigators);
            } else if (investigationType < 0.4) {
                generateClueDiscussion(investigators);
            } else if (investigationType < 0.6) {
                generateGroupTheory(investigators);
            } else if (investigationType < 0.75) {
                generateEvidenceAnalysis(investigators);
            } else if (investigationType < 0.9) {
                generateWitnessInterview(investigators);
            } else {
                generateConspiracyTheory(investigators);
            }
        }

        function generateSuspicionAccusation(investigators) {
            const accuser = investigators[0];
            const mostSuspected = accuser.memory.getMostSuspected();
            
            if (!mostSuspected || mostSuspected.level < 0.5) return;
            
            const suspect = gameState.characters.find(c => c.id == mostSuspected.id);
            if (!suspect || suspect.status !== 'Alive') return;

            const isKillerAccused = gameState.killers.includes(suspect);
            const suspicionData = accuser.memory.suspicions.get(mostSuspected.id);
            
            addEvent('event', `🔍 ACCUSATION: ${accuser.name} confronts ${suspect.name} with their suspicions`);
            
            // Accuser's statement
            const evidence = suspicionData.evidence[0] || 'suspicious behavior';
            addEvent('dialogue', generateAccusationDialogue(accuser, suspect, evidence));
            
            // Suspect's response
            setTimeout(() => {
                addEvent('dialogue', generateDefenseDialogue(suspect, accuser, isKillerAccused));
                
                // Update group dynamics based on accusation
                updateGroupDynamicsAfterAccusation(accuser, suspect, isKillerAccused);
            }, 1000);
        }

        function generateAccusationDialogue(accuser, suspect, evidence) {
            const accuserArchetype = accuser.archetype.name;
            const suspectName = suspect.name;
            
            const accusations = {
                'The Nerd': [
                    `"My analysis clearly shows ${suspectName} is the killer! The evidence is undeniable!"`,
                    `"According to my calculations, ${suspectName} has been present at every murder scene!"`,
                    `"The data doesn't lie - ${suspectName} is our killer!"`
                ],
                'The Final Girl': [
                    `"I've been watching you, ${suspectName}. You're the killer, aren't you?!"`,
                    `"${suspectName}, I know it's you! Stop this madness now!"`,
                    `"Everyone needs to hear this - ${suspectName} is the one killing us!"`
                ],
                'The Reporter': [
                    `"I've been investigating, and all the evidence points to ${suspectName}!"`,
                    `"${suspectName}, care to explain why you're always conveniently absent during murders?"`,
                    `"The truth is out, ${suspectName} - you're our killer!"`
                ],
                'default': [
                    `"It's ${suspectName}! They're the killer! I saw ${evidence}!"`,
                    `"${suspectName} has been acting suspicious all night!"`,
                    `"Everyone needs to know - ${suspectName} is trying to kill us all!"`
                ]
            };
            
            const dialogueSet = accusations[accuserArchetype] || accusations.default;
            const dialogue = dialogueSet[Math.floor(Math.random() * dialogueSet.length)];
            
            return `"${dialogue}" - ${accuser.name}, pointing accusingly`;
        }

        function generateDefenseDialogue(suspect, accuser, isActualKiller) {
            const suspectArchetype = suspect.archetype.name;
            const accuserName = accuser.name;
            
            if (isActualKiller) {
                // Killer trying to deflect
                const killerDefenses = [
                    `"You're crazy, ${accuserName}! Why would I hurt anyone?"`,
                    `"That's ridiculous! You're just trying to distract from your own guilt!"`,
                    `"${accuserName}, you're losing it. I'm trying to help everyone here!"`,
                    `"This is insane! I would never... why would you even think that?"`
                ];
                return `"${killerDefenses[Math.floor(Math.random() * killerDefenses.length)]}" - ${suspect.name}, looking nervous`;
            } else {
                // Innocent person defending themselves
                const innocentDefenses = {
                    'The Innocent': [
                        `"I would never hurt anyone! How could you even think that, ${accuserName}?"`,
                        `"This is horrible! I'm just trying to survive like everyone else!"`,
                        `"Please believe me - I'm not a killer! I'm just scared!"`
                    ],
                    'The Coward': [
                        `"Are you insane?! I can barely hurt a fly! I'm too scared to be a killer!"`,
                        `"${accuserName}, you've lost your mind! I've been hiding this whole time!"`,
                        `"I'm way too much of a coward to kill anyone!"`
                    ],
                    'The Drama Queen': [
                        `"HOW DARE YOU accuse me, ${accuserName}! This is the WORST betrayal!"`,
                        `"I am INNOCENT! This is like being falsely accused in a bad soap opera!"`,
                        `"${accuserName}, you're RUINING my reputation with these accusations!"`
                    ],
                    'default': [
                        `"That's not true, ${accuserName}! I'm innocent!"`,
                        `"You're wrong about me! I would never kill anyone!"`,
                        `"${accuserName}, you're making a terrible mistake!"`
                    ]
                };
                
                const dialogueSet = innocentDefenses[suspectArchetype] || innocentDefenses.default;
                const dialogue = dialogueSet[Math.floor(Math.random() * dialogueSet.length)];
                
                return `"${dialogue}" - ${suspect.name}, shocked and defensive`;
            }
        }

        function updateGroupDynamicsAfterAccusation(accuser, suspect, isKillerAccused) {
            const aliveCharacters = gameState.characters.filter(c => 
                c.status === 'Alive' && !gameState.killers.includes(c)
            );
            
            aliveCharacters.forEach(character => {
                if (character.id === accuser.id || character.id === suspect.id) return;
                
                // Characters react based on their intelligence and relationship to both parties
                const trustInAccuser = character.memory.getTrustLevel(accuser.id);
                const trustInSuspect = character.memory.getTrustLevel(suspect.id);
                
                if (isKillerAccused) {
                    // Correct accusation - increase trust in accuser, decrease trust in suspect
                    character.memory.updateTrust(accuser.id, 0.2);
                    character.memory.updateTrust(suspect.id, -0.4);
                    character.memory.addSuspicion(suspect.id, 'accused_by_trusted_source', 0.6, `${accuser.name} accused them`);
                } else {
                    // Wrong accusation - might hurt accuser's credibility
                    if (trustInSuspect > 0.6) {
                        character.memory.updateTrust(accuser.id, -0.1);
                    }
                }
                
                // Add this as an experience
                character.memory.addExperience({
                    type: 'accusation_witnessed',
                    accuser: accuser,
                    suspect: suspect,
                    isCorrect: isKillerAccused
                });
            });
        }

        function generateClueDiscussion(investigators) {
            if (investigators.length < 2) return;
            
            const char1 = investigators[0];
            const char2 = investigators[1];
            
            // Share clues between investigators
            const clues1 = char1.memory.shareCluesWith(char2);
            const clues2 = char2.memory.shareCluesWith(char1);
            
            if (clues1.length === 0 && clues2.length === 0) return;
            
            addEvent('event', `🧩 INVESTIGATION: ${char1.name} and ${char2.name} share what they've discovered`);
            
            if (clues1.length > 0) {
                const clue = clues1[0];
                addEvent('dialogue', `"I found something important - ${clue.description}!" - ${char1.name}`);
                
                // char2 learns this clue
                char2.memory.clues.push({...clue, learnedFrom: char1.name});
            }
            
            setTimeout(() => {
                if (clues2.length > 0) {
                    const clue = clues2[0];
                    addEvent('dialogue', `"That reminds me - ${clue.description}!" - ${char2.name}`);
                    
                    // char1 learns this clue
                    char1.memory.clues.push({...clue, learnedFrom: char2.name});
                }
                
                // Increase trust between investigators
                char1.memory.updateTrust(char2.id, 0.1);
                char2.memory.updateTrust(char1.id, 0.1);
            }, 800);
        }

        function generateGroupTheory(investigators) {
            const theorist = investigators[0];
            const mostSuspected = theorist.memory.getMostSuspected();
            
            addEvent('event', `💭 THEORY: ${theorist.name} shares their thoughts about the killer`);
            
            if (mostSuspected && mostSuspected.level > 0.4) {
                const suspect = gameState.characters.find(c => c.id == mostSuspected.id);
                if (suspect) {
                    addEvent('dialogue', generateTheoryDialogue(theorist, suspect));
                }
            } else {
                addEvent('dialogue', generateGeneralTheoryDialogue(theorist));
            }
        }

        function generateTheoryDialogue(theorist, suspect) {
            const theories = [
                `"I think ${suspect.name} might be our killer. They've been acting strange..."`,
                `"Has anyone else noticed ${suspect.name}'s behavior? Something's not right."`,
                `"We need to watch ${suspect.name} carefully. I don't trust them."`,
                `"My gut tells me ${suspect.name} is hiding something from us."`
            ];
            
            return `"${theories[Math.floor(Math.random() * theories.length)]}" - ${theorist.name}, thoughtfully`;
        }

        function generateGeneralTheoryDialogue(theorist) {
            const theories = [
                `"The killer has to be someone we know. Someone close to us."`,
                `"I think the killer is trying to pick us off one by one."`,
                `"We need to figure out the killer's pattern before it's too late."`,
                `"The killer is smart - they're making this look random but it's not."`
            ];
            
            return `"${theories[Math.floor(Math.random() * theories.length)]}" - ${theorist.name}, analyzing`;
        }
        
        function generateEvidenceAnalysis(investigators) {
            const investigator = investigators[0];
            
            addEvent('event', `🔬 EVIDENCE ANALYSIS: ${investigator.name} examines the crime scene for clues`);
            
            const analysisFindings = [
                "I found blood spatter patterns that suggest the killer is left-handed.",
                "These footprints are size 10... and they're fresh.",
                "The killer used a blade approximately 6 inches long - probably a kitchen knife.",
                "There are defensive wounds here. The victim fought back hard.",
                "This isn't random - the killer knew exactly where to strike.",
                "I found fibers that don't match any of our clothing.",
                "The killer cleaned up... but they missed this bloodstain.",
                "Based on the entry angle, the killer is approximately 5'8\" tall.",
                "These cuts are precise. Our killer has medical knowledge.",
                "The victim was moved after death - this isn't where they died."
            ];
            
            const finding = analysisFindings[Math.floor(Math.random() * analysisFindings.length)];
            addEvent('dialogue', `"${finding}" - ${investigator.name}, analytical`);
            
            // Add the evidence to investigator's memory
            investigator.memory.addClue({
                type: 'forensic_evidence',
                description: finding,
                location: 'crime scene',
                act: gameState.currentAct,
                timestamp: Date.now()
            });
        }
        
        function generateWitnessInterview(investigators) {
            const interviewer = investigators[0];
            const witness = investigators[1] || investigators[0];
            
            addEvent('event', `👁️ WITNESS INTERVIEW: ${interviewer.name} questions ${witness.name} about what they saw`);
            
            const witnessStatements = [
                "I heard strange noises coming from upstairs around midnight.",
                "Someone was definitely moving around in the kitchen when we were all supposed to be asleep.",
                "I saw a shadow pass by the window, but when I looked again, nothing was there.",
                "The killer was wearing all black - I couldn't see their face.",
                "I heard them whispering to themselves... it was really creepy.",
                "They knew exactly where to find us. Like they'd been watching.",
                "I smelled cologne... or perfume. Something floral.",
                "They moved so quietly, like they've done this before.",
                "I saw them washing something in the sink afterwards.",
                "There was something familiar about the way they walked..."
            ];
            
            const statement = witnessStatements[Math.floor(Math.random() * witnessStatements.length)];
            addEvent('dialogue', `"${statement}" - ${witness.name}, recalling details`);
            
            // Interviewer responds
            setTimeout(() => {
                const responses = [
                    "That's important information. Can you remember anything else?",
                    "We need to tell the others about this immediately.",
                    "This could help us identify the killer.",
                    "Are you absolutely sure about what you saw?",
                    "That detail might be the key to solving this."
                ];
                const response = responses[Math.floor(Math.random() * responses.length)];
                addEvent('dialogue', `"${response}" - ${interviewer.name}, focused`);
            }, 1000);
        }
        
        function generateConspiracyTheory(investigators) {
            const theorist = investigators[0];
            
            addEvent('event', `🕵️ CONSPIRACY THEORY: ${theorist.name} presents a wild theory about what's really happening`);
            
            const conspiracies = [
                "What if this is all an elaborate game show and we're being filmed?",
                "Maybe we're dealing with more than one killer... a whole network!",
                "This could be connected to that unsolved murder from five years ago.",
                "What if one of us isn't who they claim to be?",
                "I think we're being tested... but by who? And why?",
                "This house has a dark history. Maybe we're dealing with something supernatural.",
                "What if the killer is someone we thought was already dead?",
                "This feels like psychological warfare. Someone's messing with our minds.",
                "Maybe we were all chosen for a reason. We must have something in common.",
                "What if this is revenge for something we don't even remember doing?"
            ];
            
            const theory = conspiracies[Math.floor(Math.random() * conspiracies.length)];
            addEvent('dialogue', `"${theory}" - ${theorist.name}, conspiracy theorist`);
            
            // Other investigator reacts
            if (investigators[1]) {
                setTimeout(() => {
                    const reactions = [
                        "That's... actually not as crazy as it sounds.",
                        "You've been watching too many horror movies.",
                        "But what if you're right? That's terrifying.",
                        "I hate to say it, but that makes sense.",
                        "Now you're just trying to freak me out more."
                    ];
                    const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                    addEvent('dialogue', `"${reaction}" - ${investigators[1].name}, skeptical`);
                }, 1200);
            }
        }

        function updateGroupDynamicsAfterDeath(witness, victim) {
            const aliveCharacters = gameState.characters.filter(c => 
                c.status === 'Alive' && !gameState.killers.includes(c) && c.id !== witness.id
            );
            
            // Death traumatizes everyone - general trust decreases
            aliveCharacters.forEach(character => {
                character.memory.updateTrust(witness.id, -0.05); // Slight trust decrease
                witness.memory.updateTrust(character.id, -0.05);
                
                // Increase trauma levels
                character.memory.traumaLevel += 0.1;
                witness.memory.traumaLevel += 0.2; // Witnesses are more traumatized
                
                // Update behavior patterns based on trauma
                updateBehaviorPattern(character);
                updateBehaviorPattern(witness);
            });
            
            // Close relationships with victim create stronger trauma and suspicion
            const victimRelationships = getCharacterRelationships(victim);
            victimRelationships.forEach(rel => {
                if (rel.character.status === 'Alive' && !gameState.killers.includes(rel.character)) {
                    rel.character.memory.traumaLevel += 0.3;
                    
                    // Close friends/family become more suspicious of everyone
                    if (rel.relationship.type === relationshipTypes.ROMANTIC || 
                        rel.relationship.type === relationshipTypes.FAMILY ||
                        rel.relationship.type === relationshipTypes.BEST_FRIENDS) {
                        
                        aliveCharacters.forEach(suspectChar => {
                            if (suspectChar.id !== rel.character.id) {
                                rel.character.memory.addSuspicion(
                                    suspectChar.id, 
                                    'emotional_response', 
                                    0.1, 
                                    `Lost ${victim.name}, being cautious of everyone`
                                );
                            }
                        });
                    }
                }
            });
        }
        
        function updateBehaviorPattern(character) {
            const trauma = character.memory.traumaLevel;
            const oldPattern = character.memory.behaviorPattern;
            
            if (trauma > 0.8) {
                character.memory.behaviorPattern = 'broken';
            } else if (trauma > 0.6) {
                character.memory.behaviorPattern = 'paranoid';
            } else if (trauma > 0.4) {
                character.memory.behaviorPattern = 'aggressive';
            } else if (trauma > 0.2) {
                character.memory.behaviorPattern = 'cautious';
            } else {
                character.memory.behaviorPattern = 'normal';
            }
            
            // Trigger character arc event if behavior pattern changed significantly
            if (oldPattern !== character.memory.behaviorPattern && 
                character.status === 'Alive' && 
                !gameState.killers.includes(character)) {
                generateCharacterArcEvent(character, oldPattern, character.memory.behaviorPattern);
            }
        }
        
        function generateCharacterArcEvent(character, oldPattern, newPattern) {
            const arcTransitions = {
                'normal_to_cautious': [
                    `${character.name} starts double-checking locks and looking over their shoulder constantly.`,
                    `${character.name} begins moving more carefully, clearly shaken by recent events.`,
                    `${character.name} develops a nervous habit of checking their phone for missed calls.`
                ],
                'cautious_to_aggressive': [
                    `${character.name}'s fear transforms into determination. They're done being a victim.`,
                    `${character.name} starts carrying makeshift weapons and confronting suspicious behavior.`,
                    `${character.name} becomes more confrontational, no longer willing to ignore red flags.`
                ],
                'cautious_to_paranoid': [
                    `${character.name} starts seeing threats everywhere, jumping at every shadow.`,
                    `${character.name} begins obsessively watching other characters, documenting their movements.`,
                    `${character.name} refuses to be alone with anyone, constantly seeking groups for safety.`
                ],
                'aggressive_to_broken': [
                    `${character.name}'s fighting spirit finally crumbles under the weight of trauma.`,
                    `${character.name} stops trying to fight back, overwhelmed by hopelessness.`,
                    `${character.name} retreats into themselves, no longer caring about survival.`
                ],
                'paranoid_to_broken': [
                    `${character.name}'s constant vigilance exhausts them into defeat.`,
                    `${character.name} gives up on trying to identify the killer, accepting their fate.`,
                    `${character.name} becomes catatonic, unable to process any more horror.`
                ]
            };
            
            const transitionKey = `${oldPattern}_to_${newPattern}`;
            const transitions = arcTransitions[transitionKey];
            
            if (transitions) {
                const transition = transitions[Math.floor(Math.random() * transitions.length)];
                addEvent('character-arc', `🎭 CHARACTER ARC: ${transition}`);
                
                // Add archetype-specific dialogue reaction
                setTimeout(() => {
                    const dialogue = generateCharacterArcDialogue(character, newPattern);
                    if (dialogue) {
                        addEvent('dialogue', dialogue);
                    }
                }, 1000);
            }
        }
        
        function generateCharacterArcDialogue(character, behaviorPattern) {
            const archetype = character.archetype;
            
            const arcDialogue = {
                'cautious': {
                    'The Innocent': [
                        `"I... I don't think I can trust anyone anymore."`,
                        `"What if the killer is someone we know?"`,
                        `"I just want to go home and pretend this never happened."`
                    ],
                    'The Coward': [
                        `"This is exactly what I was afraid would happen!"`,
                        `"I knew something terrible was going to occur!"`,
                        `"We should have left when we had the chance!"`
                    ],
                    'The Hero': [
                        `"I need to be more careful if I'm going to protect everyone."`,
                        `"The killer is targeting us systematically. We need a plan."`,
                        `"I can't save anyone if I'm dead."`
                    ]
                },
                'aggressive': {
                    'The Hero': [
                        `"No more running. It's time to fight back!"`,
                        `"I'm done being hunted. Now I'm the hunter."`,
                        `"The killer made this personal. Big mistake."`
                    ],
                    'The Rebel': [
                        `"Screw this! I'm not going down without a fight!"`,
                        `"Time to show this psycho what happens when you mess with us!"`,
                        `"I've had enough of this horror movie BS!"`
                    ],
                    'The Tough Guy': [
                        `"Alright, killer. You want a piece of me? Come and get it!"`,
                        `"I've dealt with worse than you in my sleep!"`,
                        `"Time to end this once and for all!"`
                    ]
                },
                'paranoid': {
                    'The Intellectual': [
                        `"I've been analyzing everyone's behavior. The killer has to be among us."`,
                        `"The statistical probability suggests the murderer is someone close."`,
                        `"I'm documenting everything. One of these patterns will reveal the truth."`
                    ],
                    'The Coward': [
                        `"Everyone could be the killer! How do we know who to trust?"`,
                        `"What if there's more than one killer? What if it's all of you?"`,
                        `"I can't... I can't handle not knowing who's safe!"`
                    ]
                },
                'broken': {
                    'The Innocent': [
                        `"I can't... I just can't anymore..."`,
                        `"What's the point? We're all going to die anyway."`,
                        `"I never wanted any of this to happen..."`
                    ],
                    'The Drama Queen': [
                        `"This is it. This is how my story ends. Tragic and beautiful."`,
                        `"I suppose every leading lady must face her final act..."`,
                        `"At least I'll make a beautiful corpse..."`
                    ]
                }
            };
            
            const patternDialogue = arcDialogue[behaviorPattern];
            if (patternDialogue && patternDialogue[archetype]) {
                const options = patternDialogue[archetype];
                return `"${options[Math.floor(Math.random() * options.length)]}" - ${character.name}, ${behaviorPattern}`;
            }
            
            // Fallback generic dialogue
            const genericDialogue = {
                'cautious': `"I need to be more careful about who I trust." - ${character.name}`,
                'aggressive': `"I'm done being afraid. Time to fight back!" - ${character.name}`,
                'paranoid': `"I don't trust anyone anymore..." - ${character.name}`,
                'broken': `"What's the point of fighting anymore?" - ${character.name}`
            };
            
            return genericDialogue[behaviorPattern] || null;
        }


        function displayCastCustomization() {
            const container = document.getElementById('cast-container');
            container.innerHTML = '';
            
            gameState.characters.forEach((character, index) => {
                const card = document.createElement('div');
                card.className = character.isReturning ? 'character-card returning' : 'character-card';
                card.innerHTML = `
                    <div class="character-header">
                        <div class="character-avatar">${character.isReturning ? '🔁' : '👤'}</div>
                        <div class="character-info">
                            <h3>
                                <input type="text" value="${character.name}" onchange="updateCharacterName(${index}, this.value)" style="background: transparent; border: none; color: white; font-size: inherit; width: 100%;">
                                ${character.isReturning ? '<span style="color: #4CAF50; font-size: 0.8rem;"> (RETURNING)</span>' : ''}
                            </h3>
                            <select class="archetype" onchange="updateCharacterArchetype(${index}, this.value)">
                                ${archetypes.map(arch => `<option value="${arch.name}" ${arch.name === character.archetype.name ? 'selected' : ''}>${arch.name}</option>`).join('')}
                            </select>
                        </div>
                    </div>
                    <div class="stats-grid">
                        ${Object.entries(character.stats).map(([stat, value]) => `
                            <div class="stat">
                                <div class="stat-label">${stat.charAt(0).toUpperCase() + stat.slice(1)}</div>
                                <div class="stat-bar">
                                    <div class="stat-fill" style="width: ${value * 10}%"></div>
                                </div>
                                <input type="range" min="1" max="10" value="${value}" onchange="updateCharacterStat(${index}, '${stat}', this.value)" style="width: 100%; margin-top: 5px;">
                            </div>
                        `).join('')}
                    </div>
                    <div class="survival-chance">
                        Survival Chance: ${character.survivalChance.toFixed(1)}%
                        ${character.isReturning ? '<br><span style="color: #4CAF50; font-size: 0.9rem;">📈 Veteran Survivor Bonuses Applied!</span>' : ''}
                    </div>
                `;
                container.appendChild(card);
            });
            
            // Update the buttons at the bottom of cast customization - make this more robust
            const castContainer = document.getElementById('cast-container');
            if (castContainer && castContainer.parentNode) {
                // Remove any existing button container
                const existingButtons = castContainer.parentNode.querySelector('.cast-buttons');
                if (existingButtons) {
                    existingButtons.remove();
                }
                
                // Create new button container
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'cast-buttons';
                buttonContainer.style.textAlign = 'center';
                buttonContainer.style.marginTop = '30px';
                buttonContainer.innerHTML = `
                    <button class="btn" onclick="showRelationshipSetup()" style="background: linear-gradient(135deg, #4CAF50, #45a049); font-size: 18px; padding: 20px 30px;">
                        🔗 Setup Relationships & Start Movie
                    </button>
                    <br><br>
                    <button class="btn btn-secondary" onclick="randomizeCast()" style="margin: 5px;">🎲 Randomize All Stats</button>
                    <button class="btn btn-secondary" onclick="startMovie()" style="margin: 5px;">⏩ Skip Relationships & Start</button>
                `;
                
                // Insert after cast container
                castContainer.parentNode.insertBefore(buttonContainer, castContainer.nextSibling);
            }
            
            document.getElementById('cast-customization').classList.remove('hidden');
        }


        function showRelationshipSetup() {
            // Hide cast customization and show relationship setup
            document.getElementById('cast-customization').classList.add('hidden');
            
            // Create relationship setup screen
const setupScreen = document.createElement('div');
setupScreen.id = 'relationship-setup';
setupScreen.className = 'section';
setupScreen.innerHTML = `
    <h2>Relationship Setup</h2>
    <p style="color: #ccc; margin-bottom: 20px;">Define relationships between characters. These will affect survival chances, dialogue, and story events!</p>
    
    <div style="margin-bottom: 20px;">
        <button class="btn" onclick="generateRandomRelationships()">🎲 Generate Random Relationships</button>
        <button class="btn btn-secondary" onclick="clearAllRelationships()">🧹 Clear All</button>
    </div>
    
    <div id="relationship-pairs" style="display: grid; gap: 15px; margin-bottom: 20px;"></div>
    
    <div style="margin: 16px 0; padding: 15px; background: #1a1a1a; border: 1px solid #555; border-radius: 8px; color: #fff; font-size: 15px;">
        <strong>Relationship Legend:</strong><br/><br/>
        💕 Romantic Couple &nbsp;&nbsp;&nbsp;&nbsp;  👥 Best Friends &nbsp;&nbsp;&nbsp;&nbsp;  👪 Family &nbsp;&nbsp;&nbsp;&nbsp; ⚔️ Enemies<br/>
        💔 Ex-Lovers &nbsp;&nbsp;&nbsp;&nbsp; 🤝 Neutral/No Relationship<br/><br/>
        <div style="color: #aaa; font-size: 13px; border-top: 1px solid #555; padding-top: 10px; margin-top: 10px;">
            💡 <strong>How to use:</strong> Click any cell to cycle through relationship types. Both characters will automatically get the same relationship!
        </div>
    </div>

    <div style="text-align: center; margin-top: 20px;">
        <button class="btn" onclick="finishRelationshipSetup()">Continue to Movie</button>
        <button class="btn btn-secondary" onclick="backToCastCustomization()">Back to Cast</button>
    </div>
`;
            
            // Insert after cast customization
            const castCustomization = document.getElementById('cast-customization');
            castCustomization.parentNode.insertBefore(setupScreen, castCustomization.nextSibling);
            
            displayRelationshipPairs();
        }


        
function displayRelationshipPairs() {
    const container = document.getElementById("relationship-pairs");
    if (!container) return;
    container.innerHTML = "";

    const characters = gameState.characters;
    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";
    table.style.textAlign = "center";
    table.style.color = "#ccc";
    table.style.fontSize = "14px";

    // Header row
    let headerRow = "<tr><th></th>";
    characters.forEach(c => {
        headerRow += "<th style='padding:6px;'>" + c.name + "<br><span style='color:#888; font-size:12px;'>" + c.archetype.name + "</span></th>";
    });
    headerRow += "</tr>";
    table.innerHTML += headerRow;

    characters.forEach((rowChar, i) => {
        let rowHTML = "<tr><th style='text-align:left; padding:6px;'>" + rowChar.name + "<br><span style='color:#888; font-size:12px;'>" + rowChar.archetype.name + "</span></th>";
        characters.forEach((colChar, j) => {
            if (i === j) {
                rowHTML += "<td style='opacity:0.2;'>—</td>";
            } else {
                const rel = getRelationship(rowChar, colChar);
                const emoji = rel ? rel.type.emoji : "🤝";
                const isSpecialRelationship = emoji !== "🤝";
                const bgColor = isSpecialRelationship ? "#2a2a2a" : "transparent";
                const borderStyle = isSpecialRelationship ? "2px solid #555" : "1px solid #444";
                const originalBg = bgColor;
                rowHTML += "<td id='cell-" + rowChar.id + "-" + colChar.id + "' style='cursor:pointer; padding: 12px; border: " + borderStyle + "; background-color: " + bgColor + "; transition: all 0.2s; font-size: 18px;' onmouseover='this.style.backgroundColor=\"#333\"; this.style.transform=\"scale(1.1)\"' onmouseout='this.style.backgroundColor=\"" + originalBg + "\"; this.style.transform=\"scale(1)\"' onclick='cycleRelationship(" + rowChar.id + "," + colChar.id + ", this)'>" + emoji + "</td>";
            }
        });
        rowHTML += "</tr>";
        table.innerHTML += rowHTML;
    });

    container.appendChild(table);
}

function cycleRelationship(char1Id, char2Id, cell) {
    const char1 = gameState.characters.find(c => c.id === char1Id);
    const char2 = gameState.characters.find(c => c.id === char2Id);
    const types = Object.keys(relationshipTypes);
    const current = getRelationship(char1, char2);
    let nextIndex = 0;
    if (current) {
        const curKey = types.find(key => relationshipTypes[key] === current.type);
        nextIndex = (types.indexOf(curKey) + 1) % types.length;
    }
    const nextType = relationshipTypes[types[nextIndex]];
    createRelationship(char1, char2, nextType);
    
    // Update both cells in the matrix (bidirectional)
    updateRelationshipMatrix(char1Id, char2Id, nextType.emoji);
}

function updateRelationshipMatrix(char1Id, char2Id, emoji) {
    // Update both cells in the relationship matrix
    const cell1 = document.getElementById('cell-' + char1Id + '-' + char2Id);
    const cell2 = document.getElementById('cell-' + char2Id + '-' + char1Id);
    
    if (cell1) {
        cell1.innerHTML = emoji;
        // Add visual feedback for non-neutral relationships
        if (emoji !== '🤝') {
            cell1.style.backgroundColor = '#2a2a2a';
            cell1.style.border = '2px solid #555';
        } else {
            cell1.style.backgroundColor = 'transparent';
            cell1.style.border = '1px solid #444';
        }
    }
    if (cell2) {
        cell2.innerHTML = emoji;
        // Add visual feedback for non-neutral relationships
        if (emoji !== '🤝') {
            cell2.style.backgroundColor = '#2a2a2a';
            cell2.style.border = '2px solid #555';
        } else {
            cell2.style.backgroundColor = 'transparent';
            cell2.style.border = '1px solid #444';
        }
    }
}
function setRelationship(char1Id, char2Id, relationshipKey) {
            const char1 = gameState.characters.find(c => c.id === char1Id);
            const char2 = gameState.characters.find(c => c.id === char2Id);
            const relType = relationshipTypes[relationshipKey];
            
            if (char1 && char2 && relType) {
                createRelationship(char1, char2, relType);
            }
        }


        function generateRandomRelationships() {
            // Clear existing relationships
            gameState.relationships.clear();
            
            const characters = gameState.characters;
            const relationshipKeys = Object.keys(relationshipTypes);
            
            // Ensure at least one romantic couple and one pair of best friends
            if (characters.length >= 2) {
                const couple = [characters[0], characters[1]];
                createRelationship(couple[0], couple[1], relationshipTypes.ROMANTIC);
            }
            
            if (characters.length >= 4) {
                const friends = [characters[2], characters[3]];
                createRelationship(friends[0], friends[1], relationshipTypes.BEST_FRIENDS);
            }
            
            // Add random relationships for remaining pairs
            for (let i = 0; i < characters.length; i++) {
                for (let j = i + 1; j < characters.length; j++) {
                    const char1 = characters[i];
                    const char2 = characters[j];
                    
                    if (!getRelationship(char1, char2)) {
                        // 60% chance of neutral, 40% chance of special relationship
                        if (Math.random() < 0.6) {
                            createRelationship(char1, char2, relationshipTypes.NEUTRAL);
                        } else {
                            const randomKey = relationshipKeys[Math.floor(Math.random() * relationshipKeys.length)];
                            createRelationship(char1, char2, relationshipTypes[randomKey]);
                        }
                    }
                }
            }
            
            displayRelationshipPairs();
        }


        function clearAllRelationships() {
            gameState.relationships.clear();
            displayRelationshipPairs();
        }


        function finishRelationshipSetup() {
            // Remove relationship setup screen
            const setupScreen = document.getElementById('relationship-setup');
            if (setupScreen) {
                setupScreen.remove();
            }
            
            // Continue to movie
            startMovie();
        }


        function backToCastCustomization() {
            // Remove relationship setup screen and show cast customization
            const setupScreen = document.getElementById('relationship-setup');
            if (setupScreen) {
                setupScreen.remove();
            }
            document.getElementById('cast-customization').classList.remove('hidden');
        }


        function updateCharacterName(index, name) {
            gameState.characters[index].name = name;
        }


        function updateCharacterArchetype(index, archetypeName) {
            const archetype = archetypes.find(a => a.name === archetypeName);
            gameState.characters[index].archetype = archetype;
            gameState.characters[index].stats = { ...archetype.stats };
            gameState.characters[index].survivalChance = calculateSurvivalChance(archetype.stats);
            displayCastCustomization();
        }


        function updateCharacterStat(index, stat, value) {
            gameState.characters[index].stats[stat] = parseInt(value);
            gameState.characters[index].survivalChance = calculateSurvivalChance(gameState.characters[index].stats);
            displayCastCustomization();
        }


        function randomizeCast() {
            gameState.characters.forEach(character => {
                Object.keys(character.stats).forEach(stat => {
                    character.stats[stat] = Math.floor(Math.random() * 10) + 1;
                });
                character.survivalChance = calculateSurvivalChance(character.stats);
            });
            displayCastCustomization();
        }


        function startMovie() {
            document.getElementById('setup-screen').classList.add('hidden');
            document.getElementById('movie-screen').classList.remove('hidden');
            document.getElementById('current-movie-title').textContent = gameState.movieTitle;
            
            // Remove any relationship setup screen that might still be visible
            const setupScreen = document.getElementById('relationship-setup');
            if (setupScreen) {
                setupScreen.remove();
            }
            
            if (gameState.isKillerMode) {
                document.getElementById('killer-controls').classList.remove('hidden');
                displayKillerSelection();
            }
            
            gameState.currentAct = 1;
            gameState.events = [];
            gameState.autoPlay = false;
            gameState.movieComplete = false;
            
            // Initialize character memories for the advanced memory system
            initializeCharacterMemories();
            
            updateProgress();
            updateMovieControls();
            startAct1();
        }


        function displayKillerSelection() {
            const container = document.getElementById('killer-targets');
            container.innerHTML = '<h3>Choose your killer character from the entire cast:</h3><p style="color: #ff6666; margin-bottom: 15px;">Any character can be the killer - choose wisely!</p>';
            
            // Allow selection from ALL characters, not just pre-selected killers
            gameState.characters.forEach(character => {
                const btn = document.createElement('button');
                btn.className = 'btn';
                btn.style.margin = '5px';
                btn.style.display = 'block';
                btn.style.width = '100%';
                btn.innerHTML = `
                    <strong>${character.name}</strong> - ${character.archetype.name}
                    <br><small style="opacity: 0.8;">Stealth: ${character.stats.stealth}/10, Intelligence: ${character.stats.intelligence}/10</small>
                `;
                btn.onclick = () => selectKillerPlayer(character);
                container.appendChild(btn);
            });
        }


        function selectKillerPlayer(killer) {
            gameState.killerPlayer = killer;
            
            // Remove them from the original killers list and add them as the player killer
            gameState.killers = gameState.killers.filter(k => k.id !== killer.id);
            if (!gameState.killers.includes(killer)) {
                gameState.killers.push(killer);
            }
            
            // Show who the other killers are (if any)
            const otherKillers = gameState.killers.filter(k => k.id !== killer.id);
            let killerInfo = `
                <h3>Playing as: ${killer.name} (${killer.archetype.name})</h3>
                <p style="color: #ff4444; margin-bottom: 15px;">You are the killer! You'll get action choices throughout the movie...</p>
            `;
            
            if (otherKillers.length > 0) {
                killerInfo += `
                    <div style="background: rgba(142, 36, 170, 0.2); padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 2px solid #8e24aa;">
                        <h4 style="color: #e1bee7; margin-bottom: 10px;">🤝 YOUR ACCOMPLICE${otherKillers.length > 1 ? 'S' : ''}:</h4>
                        ${otherKillers.map(accomplice => `
                            <div style="color: #e1bee7; margin-bottom: 8px;">
                                <strong>${accomplice.name}</strong> (${accomplice.archetype.name}) - Stealth: ${accomplice.stats.stealth}/10, Intelligence: ${accomplice.stats.intelligence}/10
                            </div>
                        `).join('')}
                        <p style="color: #ddd; font-size: 0.9rem; margin-top: 10px; font-style: italic;">
                            You're working together! They'll also be killing victims throughout the movie. Coordinate your terror campaign!
                        </p>
                    </div>
                `;
            } else {
                killerInfo += `
                    <div style="background: rgba(142, 36, 170, 0.1); padding: 15px; border-radius: 8px; margin-bottom: 15px; border: 1px solid #8e24aa;">
                        <p style="color: #e1bee7; font-style: italic;">
                            🔪 You're flying solo - it's all up to you to terrorize the victims!
                        </p>
                    </div>
                `;
            }
            
            killerInfo += `
                <div style="background: rgba(255, 68, 68, 0.1); padding: 15px; border-radius: 8px;">
                    <p style="color: #ccc; margin: 0;">The movie will start soon. Watch for killer action prompts during the story!</p>
                </div>
                <div id="killer-action-area"></div>
            `;
            
            document.getElementById('killer-targets').innerHTML = killerInfo;
        }


        function showKillerActions() {
            if (!gameState.isKillerMode || !gameState.killerPlayer) return;
            
            const aliveVictims = gameState.characters.filter(c => 
                c.status === 'Alive' && c.id !== gameState.killerPlayer.id && !gameState.killers.includes(c)
            );
            
            if (aliveVictims.length === 0) {
                document.getElementById('killer-action-area').innerHTML = '<p style="color: #666;">No targets remaining...</p>';
                return;
            }
            
            const otherKillers = gameState.killers.filter(k => k.id !== gameState.killerPlayer.id && k.status === 'Alive');
            let accompliceInfo = '';
            if (otherKillers.length > 0) {
                accompliceInfo = `
                    <div style="background: rgba(142, 36, 170, 0.15); padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                        <small style="color: #e1bee7;">🤝 Working with: ${otherKillers.map(k => k.name).join(', ')}</small>
                    </div>
                `;
            }
            
            const actionArea = document.getElementById('killer-action-area');
            actionArea.innerHTML = `
                ${accompliceInfo}
                <div style="background: rgba(255, 68, 68, 0.1); padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #ff4444;">
                    <h4 style="color: #ff4444; margin-bottom: 15px;">🔪 KILLER ACTIONS AVAILABLE</h4>
                    <p style="color: #ccc; margin-bottom: 15px;">Choose your next move carefully. Each action has consequences...</p>
                    
                    <div style="display: grid; gap: 15px;">
                        <button class="btn" onclick="showKillTargets()" style="background: #8B0000;">
                            💀 Kill a Victim
                        </button>
                        <button class="btn btn-secondary" onclick="performPsychOut()">
                            👻 Psychological Torment
                        </button>
                        <button class="btn btn-secondary" onclick="plantEvidence()">
                            🔍 Plant Evidence/Red Herring
                        </button>
                        <button class="btn btn-secondary" onclick="hideAndWait()">
                            ⏰ Hide and Wait for Better Opportunity
                        </button>
                    </div>
                </div>
                
                <div id="killer-target-selection" style="display: none;">
                    <h4 style="color: #ff4444; margin-bottom: 15px;">Select Your Target:</h4>
                    <div style="display: grid; gap: 10px;">
                        ${aliveVictims.map(victim => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #333; border-radius: 5px;">
                                <div>
                                    <strong>${victim.name}</strong> - ${victim.archetype.name}
                                    <br><small style="color: #ccc;">Survival: ${victim.stats.survival}/10, Stealth: ${victim.stats.stealth}/10, Athletics: ${victim.stats.athletics}/10</small>
                                </div>
                                <button class="btn" onclick="attemptKill(${victim.id})" style="background: #8B0000; padding: 8px 15px;">
                                    Kill
                                </button>
                            </div>
                        `).join('')}
                    </div>
                    <button class="btn btn-secondary" onclick="cancelKillAction()" style="margin-top: 15px;">Cancel</button>
                </div>
            `;
        }


        function attemptKill(victimId) {
            const victim = gameState.characters.find(c => c.id === victimId);
            if (!victim || victim.status !== 'Alive') return;
            
            // Calculate success chance based on victim's stats and relationships
            const victimDefense = victim.stats.survival + victim.stats.stealth + victim.stats.athletics;
            
            // Check for relationship bonuses
            let relationshipBonus = 0;
            const victimRelationships = getCharacterRelationships(victim);
            victimRelationships.forEach(rel => {
                if (rel.character.status === 'Alive' && !gameState.killers.includes(rel.character)) {
                    relationshipBonus += rel.relationship.type.survivalBonus;
                }
            });
            
            const baseSuccessChance = 70; // Base 70% chance
            const statModifier = (30 - victimDefense) * 2; // High stat victims are harder to kill
            const relModifier = relationshipBonus * 5; // Relationships can provide up to +15% survival
            const finalChance = Math.max(30, Math.min(95, baseSuccessChance + statModifier - relModifier));
            
            const success = Math.random() * 100 < finalChance;
            
            if (success) {
                // Successful kill - check for relationship-specific death scenarios
                const victimRelationships = getCharacterRelationships(victim);
                const partnerRel = victimRelationships.find(rel => 
                    rel.relationship.type === relationshipTypes.ROMANTIC && rel.character.status === 'Alive'
                );
                const bestFriendRel = victimRelationships.find(rel => 
                    rel.relationship.type === relationshipTypes.BEST_FRIENDS && rel.character.status === 'Alive'
                );
                const familyRel = victimRelationships.find(rel => 
                    rel.relationship.type === relationshipTypes.FAMILY && rel.character.status === 'Alive'
                );
                
                let killMethod, lastWords;
                
                if (partnerRel && Math.random() < 0.6) {
                    // Romantic death scenario
                    const partner = partnerRel.character;
                    killMethod = `You catch ${victim.name} alone while they were trying to find ${partner.name}. Love makes people vulnerable.`;
                    lastWords = `"Tell ${partner.name}... I love them..." - ${victim.name}, with their final breath`;
                } else if (bestFriendRel && Math.random() < 0.5) {
                    // Best friend death scenario
                    const friend = bestFriendRel.character;
                    killMethod = `You strike while ${victim.name} is distracted worrying about ${friend.name}'s safety.`;
                    lastWords = `"${friend.name}... watch out for..." - ${victim.name}, trying to warn their friend`;
                } else if (familyRel && Math.random() < 0.5) {
                    // Family death scenario
                    const family = familyRel.character;
                    killMethod = `You exploit ${victim.name}'s protective instincts when they hear ${family.name} in danger.`;
                    lastWords = `"Keep ${family.name} safe... promise me..." - ${victim.name}, pleading`;
                } else {
                    // Standard kill methods
                    const killMethods = [
                        'You catch them alone in the kitchen and strike with a knife.',
                        'You corner them in the basement - nowhere to run.',
                        'A perfect ambush from the shadows.',
                        'You lure them outside and finish them quickly.',
                        'They never saw it coming in the dark hallway.'
                    ];
                    killMethod = killMethods[Math.floor(Math.random() * killMethods.length)];
                    lastWords = `"Wait... ${gameState.killerPlayer.name}?!" - ${victim.name}, shocked`;
                }
                
                addEvent('death', `💀 KILLER STRIKE: ${killMethod}`);
                addEvent('dialogue', lastWords);
                killCharacter(victim, gameState.killerPlayer, gameState.currentAct);
                
                // Update killer memory - successful kill
                updateKillerMemory(victim, true);
                
                // Add relationship-specific reactions from survivors
                setTimeout(() => {
                    addRelationshipReactions(victim, 'death');
                    
                    // Update witnesses' memories with evidence
                    const witnesses = gameState.characters.filter(c => 
                        c.status === 'Alive' && !gameState.killers.includes(c) && c.id !== victim.id
                    );
                    witnesses.forEach(witness => {
                        witness.memory.addExperience({
                            type: 'death',
                            victim: victim,
                            killer: gameState.killerPlayer,
                            isClose: getRelationship(witness, victim) ? true : false,
                            location: 'scene of crime'
                        });
                        
                        // Add evidence clues for witnesses
                        witness.memory.addClue({
                            type: 'death_witness',
                            description: `Witnessed ${victim.name}'s death`,
                            location: 'crime scene',
                            act: gameState.currentAct,
                            timestamp: Date.now()
                        });
                        
                        // Update group dynamics - trust decreases after deaths
                        updateGroupDynamicsAfterDeath(witness, victim);
                    });
                    
                    // Add random character reactions for more variety
                    setTimeout(() => {
                        addRandomCharacterReactions('death', 1);
                    }, 1500);
                }, 1000);
                
                addEvent('killer-thought', `You feel a rush of adrenaline. The kill was clean and efficient.`);
                
            } else {
                // Failed attempt - victim escapes, possibly with help from relationships
                const victimRelationships = getCharacterRelationships(victim);
                const nearbyAlly = victimRelationships.find(rel => 
                    rel.character.status === 'Alive' && 
                    !gameState.killers.includes(rel.character) &&
                    (rel.relationship.type === relationshipTypes.ROMANTIC || 
                     rel.relationship.type === relationshipTypes.BEST_FRIENDS ||
                     rel.relationship.type === relationshipTypes.FAMILY)
                );
                
                let escapeScenario;
                if (nearbyAlly && Math.random() < 0.4) {
                    const ally = nearbyAlly.character;
                    escapeScenario = `You attack ${victim.name} but ${ally.name} appears and helps them escape!`;
                    
                    setTimeout(() => {
                        addEvent('dialogue', `"I heard you scream! Are you okay?!" - ${ally.name}, rushing to help`);
                        addEvent('dialogue', `"${gameState.killerPlayer.name} IS THE KILLER! They just tried to kill me!" - ${victim.name}`);
                    }, 500);
                } else {
                    const escapeScenarios = [
                        `You attack ${victim.name} but they fight back and escape!`,
                        `${victim.name} spots you coming and runs screaming!`,
                        `Your strike misses and ${victim.name} kicks you, then flees!`
                    ];
                    escapeScenario = escapeScenarios[Math.floor(Math.random() * escapeScenarios.length)];
                    
                    setTimeout(() => {
                        addEvent('dialogue', `"${gameState.killerPlayer.name} IS THE KILLER! RUN!" - ${victim.name}`);
                    }, 500);
                }
                
                addEvent('attack', `⚠️ FAILED KILL ATTEMPT: ${escapeScenario}`);
                attackCharacter(victim, gameState.currentAct);
                
                // Add relationship reactions to the attack
                setTimeout(() => {
                    addRelationshipReactions(victim, 'attack');
                }, 1000);
                
                // Reveal killer to everyone if attack fails
                addEvent('reveal', `🎭 Your identity as the killer has been exposed! The survivors know it's you!`);
                addEvent('killer-thought', `Your cover is blown. The hunt is now on for YOU.`);
            }
            
            // Hide action menu and advance story
            document.getElementById('killer-action-area').innerHTML = '<p style="color: #666;">Action completed. Continuing story...</p>';
            
            // Resume automatic story progression and show force button again
            setTimeout(() => {
                const forceKillerBtn = document.getElementById('force-killer-action');
                if (forceKillerBtn && gameState.isKillerMode && gameState.killerPlayer) {
                    const aliveVictims = gameState.characters.filter(c => 
                        c.status === 'Alive' && c.id !== gameState.killerPlayer.id
                    );
                    if (aliveVictims.length > 0) {
                        forceKillerBtn.style.display = 'inline-block';
                        document.getElementById('killer-help-text').style.display = 'block';
                    }
                }
                
                // Clear the "action completed" message
                document.getElementById('killer-action-area').innerHTML = '';
                
                // Continue story automatically after killer action
                if (!gameState.autoPlay) {
                    setTimeout(() => continueStory(), 1000);
                }
            }, 3000);
            
            // Resume automatic story progression
            setTimeout(() => {
                continueStory();
            }, 2000);
        }


        function addRelationshipReactions(victim, eventType) {
            // Don't add reactions if movie is complete
            if (gameState.movieComplete) return;
            
            const victimRelationships = getCharacterRelationships(victim);
            const aliveRelationships = victimRelationships.filter(rel => 
                rel.character.status === 'Alive' && !gameState.killers.includes(rel.character)
            );
            
            aliveRelationships.forEach(rel => {
                const reactor = rel.character;
                const relType = rel.relationship.type;
                
                // Update reactor's memory with this event
                if (reactor.memory) {
                    reactor.memory.addExperience({
                        type: eventType,
                        victim: victim,
                        relationship: relType
                    });
                }
                
                // Generate relationship-specific campy dialogue
                let reaction;
                if (eventType === 'death') {
                    reaction = generateCampyDialogue(reactor, 'death', { relationshipTarget: victim });
                    
                    // Add special relationship-specific death reactions
                    if (relType === relationshipTypes.ROMANTIC) {
                        const romanticReactions = [
                            `"NO! ${victim.name}! Our love was supposed to conquer all!" - ${reactor.name}, devastated`,
                            `"I can't live without you! This is worse than any horror movie!" - ${reactor.name}, sobbing`,
                            `"${victim.name}, my heart! I'll avenge you if it's the last thing I do!" - ${reactor.name}, furious with grief`
                        ];
                        reaction = romanticReactions[Math.floor(Math.random() * romanticReactions.length)];
                    } else if (relType === relationshipTypes.BEST_FRIENDS) {
                        const friendReactions = [
                            `"My bestie! No, no, NO! We were supposed to survive this together!" - ${reactor.name}, screaming`,
                            `"${victim.name} was the sister I never had! This killer will PAY!" - ${reactor.name}, enraged`,
                            `"BFFs forever... I guess forever ended too soon!" - ${reactor.name}, crying`
                        ];
                        reaction = friendReactions[Math.floor(Math.random() * friendReactions.length)];
                    } else if (relType === relationshipTypes.FAMILY) {
                        const familyReactions = [
                            `"FAMILY DOESN'T DIE LIKE THIS! ${victim.name}, I'll make them pay!" - ${reactor.name}, rage-filled`,
                            `"They killed my blood! This is war now!" - ${reactor.name}, devastated but determined`,
                            `"${victim.name}... mom always said protect family... I failed..." - ${reactor.name}, broken`
                        ];
                        reaction = familyReactions[Math.floor(Math.random() * familyReactions.length)];
                    } else if (relType === relationshipTypes.ENEMIES) {
                        const enemyReactions = [
                            `"I may have hated ${victim.name}, but I wanted to be the one to destroy them!" - ${reactor.name}, conflicted`,
                            `"Even my worst enemy didn't deserve THAT! This killer's insane!" - ${reactor.name}, disturbed`,
                            `"${victim.name} was a jerk, but at least they were OUR jerk!" - ${reactor.name}, oddly sentimental`
                        ];
                        reaction = enemyReactions[Math.floor(Math.random() * enemyReactions.length)];
                    }
                } else if (eventType === 'attack') {
                    reaction = generateCampyDialogue(reactor, 'attack', { relationshipTarget: victim });
                    
                    // Add special relationship-specific attack reactions
                    if (relType === relationshipTypes.ROMANTIC) {
                        const loveReactions = [
                            `"DON'T YOU DARE TOUCH MY LOVE! I'll rip you apart!" - ${reactor.name}, protective fury`,
                            `"${victim.name}! Are you hurt?! This psycho picked the wrong couple!" - ${reactor.name}, checking on them`,
                            `"Nobody hurts my soulmate! NOBODY!" - ${reactor.name}, ready to fight`
                        ];
                        reaction = loveReactions[Math.floor(Math.random() * loveReactions.length)];
                    }
                }
                
                if (reaction) {
                    addEvent('dialogue', reaction);
                }
            });
        }


        function showKillTargets() {
            document.getElementById('killer-target-selection').style.display = 'block';
        }


        function cancelKillAction() {
            document.getElementById('killer-target-selection').style.display = 'none';
        }


        function performPsychOut() {
            const aliveVictims = gameState.characters.filter(c => 
                c.status === 'Alive' && c.id !== gameState.killerPlayer.id && !gameState.killers.includes(c)
            );
            
            if (aliveVictims.length === 0) return;
            
            const victim = aliveVictims[Math.floor(Math.random() * aliveVictims.length)];
            
            const psychOuts = [
                `You leave a threatening note for ${victim.name} to find.`,
                `You move ${victim.name}'s belongings around to mess with their head.`,
                `You make creepy phone calls to ${victim.name}.`,
                `You leave bloody handprints near ${victim.name}'s room.`,
                `You cut the power when ${victim.name} is alone.`,
                `You play mind games by appearing briefly in ${victim.name}'s peripheral vision.`,
                `You whisper ${victim.name}'s name from the shadows.`,
                `You leave a photo of ${victim.name} with their face scratched out.`
            ];
            
            const psychOut = psychOuts[Math.floor(Math.random() * psychOuts.length)];
            addEvent('event', `👻 PSYCHOLOGICAL WARFARE: ${psychOut}`);
            
            const victimReactions = [
                `"I'm losing my mind... or someone's messing with me." - ${victim.name}`,
                `"This isn't funny anymore. Someone's trying to scare me." - ${victim.name}`,
                `"I feel like I'm being watched constantly." - ${victim.name}`,
                `"Someone is definitely trying to get inside my head." - ${victim.name}`,
                `"I'm not imagining this. Someone wants me scared." - ${victim.name}`
            ];
            
            addEvent('dialogue', victimReactions[Math.floor(Math.random() * victimReactions.length)]);
            addEvent('killer-thought', `You smile behind your mask. Fear is almost as satisfying as the kill itself.`);
            
            document.getElementById('killer-action-area').innerHTML = '<p style="color: #666;">Psychological torment complete. Continuing story...</p>';
            
            // Show the force killer action button again after completing an action
            setTimeout(() => {
                const forceKillerBtn = document.getElementById('force-killer-action');
                if (forceKillerBtn && gameState.isKillerMode && gameState.killerPlayer) {
                    const aliveVictims = gameState.characters.filter(c => 
                        c.status === 'Alive' && c.id !== gameState.killerPlayer.id && !gameState.killers.includes(c)
                    );
                    if (aliveVictims.length > 0) {
                        forceKillerBtn.style.display = 'inline-block';
                        document.getElementById('killer-help-text').style.display = 'block';
                    }
                }
                document.getElementById('killer-action-area').innerHTML = '';
                
                // Continue story automatically after killer action
                if (!gameState.autoPlay) {
                    setTimeout(() => continueStory(), 1000);
                }
            }, 3000);
            
            setTimeout(() => {
                continueStory();
            }, 1500);
        }


        function plantEvidence() {
            const aliveInnocents = gameState.characters.filter(c => 
                c.status === 'Alive' && c.id !== gameState.killerPlayer.id
            );
            
            if (aliveInnocents.length < 2) {
                addEvent('event', `🔍 You try to plant evidence but there aren't enough targets remaining.`);
                document.getElementById('killer-action-area').innerHTML = '<p style="color: #666;">Not enough targets. Continuing story...</p>';
                setTimeout(() => continueStory(), 1000);
                return;
            }
            
            const target = aliveInnocents[Math.floor(Math.random() * aliveInnocents.length)];
            
            const evidencePlants = [
                `You plant bloody clothing in ${target.name}'s room.`,
                `You hide a murder weapon in ${target.name}'s backpack.`,
                `You forge incriminating text messages on ${target.name}'s phone.`,
                `You leave ${target.name}'s fingerprints on a suspicious item.`,
                `You spread rumors about ${target.name}'s suspicious behavior.`,
                `You plant photos that make ${target.name} look guilty.`,
                `You stage evidence to make ${target.name} look unhinged.`,
                `You manipulate the crime scene to point to ${target.name}.`
            ];
            
            const plant = evidencePlants[Math.floor(Math.random() * evidencePlants.length)];
            addEvent('red-herring', `🔍 EVIDENCE PLANTED: ${plant}`);
            
            addEvent('killer-thought', `Perfect. Let them turn on each other while you watch from the shadows.`);
            
            document.getElementById('killer-action-area').innerHTML = '<p style="color: #666;">Evidence planted successfully. Continuing story...</p>';
            
            // Show the force killer action button again after completing an action
            setTimeout(() => {
                const forceKillerBtn = document.getElementById('force-killer-action');
                if (forceKillerBtn && gameState.isKillerMode && gameState.killerPlayer) {
                    const aliveVictims = gameState.characters.filter(c => 
                        c.status === 'Alive' && c.id !== gameState.killerPlayer.id
                    );
                    if (aliveVictims.length > 0) {
                        forceKillerBtn.style.display = 'inline-block';
                    }
                }
                document.getElementById('killer-action-area').innerHTML = '';
            }, 3000);
            
            setTimeout(() => {
                continueStory();
            }, 1500);
        }


        function hideAndWait() {
            addEvent('killer-thought', `You retreat to the shadows, biding your time for the perfect moment to strike...`);
            addEvent('event', `The killer seems to have vanished. An eerie calm settles over the house.`);
            
            const waitingDialogue = [
                `"Where did they go? This silence is worse than the attacks." - Random survivor`,
                `"They're still here. I can feel them watching us." - Random survivor`,
                `"This is psychological torture. They want us scared." - Random survivor`,
                `"The quiet is making me more nervous than the attacks." - Random survivor`
            ];
            
            addEvent('dialogue', waitingDialogue[Math.floor(Math.random() * waitingDialogue.length)]);
            addEvent('killer-thought', `Patience is a killer's greatest weapon. Your time will come.`);
            
            document.getElementById('killer-action-area').innerHTML = '<p style="color: #666;">Hiding in the shadows. Continuing story...</p>';
            
            // Show the force killer action button again after completing an action
            setTimeout(() => {
                const forceKillerBtn = document.getElementById('force-killer-action');
                if (forceKillerBtn && gameState.isKillerMode && gameState.killerPlayer) {
                    const aliveVictims = gameState.characters.filter(c => 
                        c.status === 'Alive' && c.id !== gameState.killerPlayer.id
                    );
                    if (aliveVictims.length > 0) {
                        forceKillerBtn.style.display = 'inline-block';
                    }
                }
                document.getElementById('killer-action-area').innerHTML = '';
            }, 3000);
            
            setTimeout(() => {
                continueStory();
            }, 1500);
        }


        function forceKillerAction() {
            if (!gameState.isKillerMode || !gameState.killerPlayer) return;
            
            createBeep(600, 0.1);
            showKillerActions();
            
            // Hide the force button while actions are being chosen
            document.getElementById('force-killer-action').style.display = 'none';
            document.getElementById('killer-help-text').style.display = 'none';
        }


        function updateProgress() {
            const progress = (gameState.currentAct / 3) * 100;
            document.getElementById('movie-progress').style.width = progress + '%';
            document.getElementById('current-act-display').textContent = `Act ${gameState.currentAct}`;
        }


        function startAct1() {
            gameState.storyQueue = [];
            gameState.currentStoryIndex = 0;
            
            // Queue up Act 1 events
            gameState.storyQueue.push({
                type: 'title',
                text: `🎬 ${gameState.movieTitle.toUpperCase()} - ACT 1 🎬`,
                delay: 1000
            });
            
            // Add sequel opening if there are returning characters
            const returningCharacters = gameState.characters.filter(c => c.isReturning);
            if (returningCharacters.length > 0) {
                gameState.storyQueue.push({
                    type: 'narrative',
                    text: `The survivors thought they were safe... they were wrong. ${returningCharacters.length > 1 ? 'Our returning survivors' : 'Our returning survivor'} ${returningCharacters.map(c => c.name).join(' and ')} hoped to move on with ${returningCharacters.length > 1 ? 'their' : 'their'} life, but the nightmare has found ${returningCharacters.length > 1 ? 'them' : 'them'} again...`,
                    delay: 2000
                });
                
                gameState.storyQueue.push({
                    type: 'function',
                    func: () => addSequelReferences(),
                    delay: 2000
                });
            } else {
                gameState.storyQueue.push({
                    type: 'narrative',
                    text: 'The night is young, and our unsuspecting victims gather...',
                    delay: 2000
                });
            }
            
            // Opening kill
            gameState.storyQueue.push({
                type: 'function',
                func: () => performOpeningKill(),
                delay: 1000
            });
            
            // Act 1 events - simplified to ensure killer actions work
            gameState.storyQueue.push({
                type: 'function',
                func: () => addGroupEvent(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterMoment(),
                delay: 2000
            });
            
            // Add sequel reference if applicable
            if (gameState.characters.some(c => c.isReturning)) {
                gameState.storyQueue.push({
                    type: 'function',
                    func: () => {
                        if (Math.random() < 0.5) addSequelReferences();
                        else addQuietMoment();
                    },
                    delay: 1500
                });
            } else {
                gameState.storyQueue.push({
                    type: 'function',
                    func: () => addQuietMoment(),
                    delay: 1500
                });
            }
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => performRandomKill(),
                delay: 3000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addTensionMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterInteraction(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addJumpScare(),
                delay: 1500
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addRelationshipDrama(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addRedHerring(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => performRandomKill(),
                delay: 3000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addTensionMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addDiscoveryEvent(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateInvestigationEvent(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => performRandomAttack(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => endAct1(),
                delay: 1000
            });
            
            updateMovieControls();
            
            if (gameState.autoPlay) {
                playNextStoryEvent();
            } else {
                updateStoryStatus();
            }
        }


        function performOpeningKill() {
            const aliveCharacters = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            if (aliveCharacters.length === 0) return;
            
            const victim = aliveCharacters[Math.floor(Math.random() * aliveCharacters.length)];
            const killer = gameState.killers[Math.floor(Math.random() * gameState.killers.length)];
            
            const openingKills = [
                `${victim.name} answers the phone at exactly 11:47 PM. "Hello?" Click. They hang up and walk to the kitchen for a late-night snack when WHAM! A meat cleaver splits their skull like a watermelon.`,
                `${victim.name} is taking a steamy shower when the lights flicker. "Hello? Is someone there?" The shower curtain gets yanked back and a masked figure plunges a kitchen knife into their chest seven times.`,
                `${victim.name} hears scratching at the window. "Probably just a tree branch," they mutter, opening the blinds. CRASH! The killer bursts through the glass, tackling them to the ground and strangling them with piano wire.`,
                `${victim.name} is alone in the garage working on their car when the garage door suddenly slams shut. The killer emerges from behind a tool cabinet and impales them on a garden rake.`,
                `${victim.name} is studying late at night when they hear the doorbell ring. "Pizza's here!" they call out, opening the door without checking. Instead of pizza, they get a chainsaw to the face.`,
                `${victim.name} is doing laundry in the basement when the washing machine starts making weird noises. They lean in to check and the killer grabs them from behind, shoving their head into the spin cycle.`,
                `${victim.name} decides to take out the trash during a thunderstorm. Lightning flashes as they reach the dumpster, revealing the killer standing behind it. A machete swing later, and ${victim.name} becomes part of the garbage.`,
                `${victim.name} is home alone watching TV when the power goes out. They grab a flashlight and head to the breaker box, only to find the killer waiting with a pair of bolt cutters. SNAP! goes more than just the power.`,
                `${victim.name} is making a midnight snack when they hear their dog barking outside. "What's wrong, boy?" They open the back door to find their dog... and the killer holding a bloody shovel.`,
                `${victim.name} is video chatting with friends when the wifi cuts out. "Ugh, typical!" They head upstairs to reset the router and walk straight into a tripwire that sends them tumbling down the stairs... into a pit of kitchen knives.`
            ];
            
            const kill = openingKills[Math.floor(Math.random() * openingKills.length)];
            addEvent('death', `💀 OPENING KILL: ${kill}`);
            
            const lastWords = [
                `"Wait... ${killer.name}? But why would you—" *THUD*`,
                `"I knew I should have stayed home and binge-watched The Office!" *gurgling sounds*`,
                `"This is just like that movie we watched last week!" *screaming*`,
                `"Mom always said don't trust anyone... guess she was right." *choking*`,
                `"But we're supposed to be friends! We had study group together!" *gasping*`,
                `"I always thought I'd die from something cooler, like skydiving!" *whimpering*`,
                `"Please, I'll do anything! I'll even delete my TikTok!" *sobbing*`,
                `"You're making a huge mistake! I have terrible Yelp reviews to write!" *coughing up blood*`,
                `"I should have listened to my gut feeling... and my horoscope..." *dying breath*`,
                `"This is so not going in my Instagram story!" *final gasp*`,
                `"Wait, can I at least post one last selfie?" *choking*`,
                `"I haven't even finished watching Stranger Things yet!" *gasping*`,
                `"My mom is going to be SO mad about this!" *wheezing*`,
                `"I was supposed to return my library books tomorrow!" *struggling*`,
                `"Tell my followers I died doing what I loved... being dramatic!" *theatrical death*`
            ];
            
            addEvent('dialogue', lastWords[Math.floor(Math.random() * lastWords.length)]);
            
            killCharacter(victim, killer, 1);
        }


        function killCharacter(victim, killer, act) {
            victim.status = 'Dead';
            victim.actStatuses[act] = 'Killed';
            victim.killedBy = killer.name;
            victim.deathAct = act;
            
            // Update edgic for dramatic death
            victim.edgic[act] = 'CP5';
        }


        function attackCharacter(victim, act) {
            if (victim.status === 'Alive') {
                victim.actStatuses[act] = 'Attacked';
                victim.edgic[act] = 'CP4';
            }
        }


        function performRandomKill() {
            const aliveCharacters = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            if (aliveCharacters.length === 0) return;
            
            // 40% chance to target based on relationships (isolation, revenge, etc.)
            let victim;
            if (Math.random() < 0.4) {
                victim = selectRelationshipBasedVictim(aliveCharacters);
            }
            
            // Fallback to random selection
            if (!victim) {
                victim = aliveCharacters[Math.floor(Math.random() * aliveCharacters.length)];
            }
            
            const killer = gameState.killers[Math.floor(Math.random() * gameState.killers.length)];
            
            // Get relationship-specific kill scenario
            const killScenario = getRelationshipAwareKillScenario(victim, killer);
            addEvent('death', `💀 ${killScenario}`);
            
            // Get relationship-specific final words
            const finalWords = getRelationshipAwareFinalWords(victim, killer);
            addEvent('dialogue', finalWords);
            
            killCharacter(victim, killer, gameState.currentAct);
            
            // Update killer memory - successful kill
            updateKillerMemory(victim, true);
            
            // Add relationship reactions
            setTimeout(() => {
                addRelationshipReactions(victim, 'death');
                // Add random character reactions for more variety
                setTimeout(() => {
                    addRandomCharacterReactions('death', 1);
                }, 1500);
            }, 1000);
        }


        function selectRelationshipBasedVictim(aliveCharacters) {
            // Strategy 1: Target isolated characters (those with fewer strong relationships)
            const isolatedChars = aliveCharacters.filter(char => {
                const relationships = getCharacterRelationships(char);
                const strongRels = relationships.filter(rel => 
                    rel.character.status === 'Alive' && 
                    (rel.relationship.type === relationshipTypes.ROMANTIC || 
                     rel.relationship.type === relationshipTypes.BEST_FRIENDS ||
                     rel.relationship.type === relationshipTypes.FAMILY)
                );
                return strongRels.length <= 1; // 1 or fewer strong relationships
            });
            
            if (isolatedChars.length > 0 && Math.random() < 0.6) {
                return isolatedChars[Math.floor(Math.random() * isolatedChars.length)];
            }
            
            // Strategy 2: Target someone with enemies (easier to frame/less sympathy)
            const charsWithEnemies = aliveCharacters.filter(char => {
                const relationships = getCharacterRelationships(char);
                return relationships.some(rel => 
                    rel.character.status === 'Alive' && 
                    rel.relationship.type === relationshipTypes.ENEMIES
                );
            });
            
            if (charsWithEnemies.length > 0 && Math.random() < 0.3) {
                return charsWithEnemies[Math.floor(Math.random() * charsWithEnemies.length)];
            }
            
            // Strategy 3: Target to cause maximum emotional damage (kill someone's loved one)
            const romanticTargets = [];
            findCharactersByRelationType(relationshipTypes.ROMANTIC).forEach(pair => {
                if (pair[0].status === 'Alive' && pair[1].status === 'Alive') {
                    if (aliveCharacters.includes(pair[0])) romanticTargets.push(pair[0]);
                    if (aliveCharacters.includes(pair[1])) romanticTargets.push(pair[1]);
                }
            });
            
            if (romanticTargets.length > 0 && Math.random() < 0.4) {
                return romanticTargets[Math.floor(Math.random() * romanticTargets.length)];
            }
            
            return null; // No strategic target found, use random
        }


        function getRelationshipAwareKillScenario(victim, killer) {
            const victimRelationships = getCharacterRelationships(victim);
            const partnerRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.ROMANTIC && rel.character.status === 'Alive'
            );
            const bestFriendRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.BEST_FRIENDS && rel.character.status === 'Alive'
            );
            const enemyRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.ENEMIES && rel.character.status === 'Alive'
            );
            const familyRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.FAMILY && rel.character.status === 'Alive'
            );
            
            // Relationship-specific kill scenarios
            if (partnerRel && Math.random() < 0.5) {
                const partner = partnerRel.character;
                return `${victim.name} is looking for ${partner.name} when the killer strikes. Love blinds them to the danger lurking in the shadows.`;
            }
            
            if (bestFriendRel && Math.random() < 0.4) {
                const friend = bestFriendRel.character;
                return `${victim.name} goes to warn ${friend.name} about the danger, but walks straight into the killer's trap.`;
            }
            
            if (familyRel && Math.random() < 0.4) {
                const family = familyRel.character;
                return `${victim.name} hears ${family.name} calling for help and rushes to save them - right into the killer's arms.`;
            }
            
            if (enemyRel && Math.random() < 0.3) {
                const enemy = enemyRel.character;
                return `${victim.name} is found dead with evidence pointing to ${enemy.name}. The perfect frame job.`;
            }
            
            // Fallback to original scenarios
            const killScenarios = [
                `${victim.name} goes to the basement to check the breaker box when the lights go out. "Great, just great," they mutter, fumbling with their phone flashlight. The killer appears behind them with a nail gun - THUNK THUNK THUNK!`,
                `${victim.name} is making popcorn in the kitchen when they hear the microwave beeping weirdly. They open it to find a bloody note that says "YOU'RE NEXT." Suddenly, the killer grabs them from behind and shoves their head into the garbage disposal.`,
                `${victim.name} decides to "split up to cover more ground" (classic mistake). They're searching the attic when a floorboard creaks. "Hello?" The killer drops down from the rafters and strangles them with Christmas lights.`,
                `${victim.name} is in the bathroom applying lipgloss when they notice in the mirror that the shower curtain is moving. "Very funny, guys!" The killer bursts out and drowns them in the toilet.`,
                `${victim.name} goes outside to get something from their car. The killer pops out of the backseat like a jack-in-the-box and beheads them with a machete. Their head rolls under the car and their body slumps against the horn - HOOOOONK!`
            ];
            
            return killScenarios[Math.floor(Math.random() * killScenarios.length)];
        }


        function getRelationshipAwareFinalWords(victim, killer) {
            const victimRelationships = getCharacterRelationships(victim);
            const partnerRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.ROMANTIC && rel.character.status === 'Alive'
            );
            const bestFriendRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.BEST_FRIENDS && rel.character.status === 'Alive'
            );
            const familyRel = victimRelationships.find(rel => 
                rel.relationship.type === relationshipTypes.FAMILY && rel.character.status === 'Alive'
            );
            
            // Relationship-specific final words
            if (partnerRel && Math.random() < 0.6) {
                const partner = partnerRel.character;
                const romanticLastWords = [
                    `"Tell ${partner.name}... I love them... always..." - ${victim.name}, with their dying breath`,
                    `"${partner.name}... I'm sorry... we'll never get that happy ending..." - ${victim.name}, tears in their eyes`,
                    `"Promise me... you'll keep ${partner.name} safe..." - ${victim.name}, looking at the killer`,
                    `"${partner.name} and I... we were going to... get married..." - ${victim.name}, fading away`
                ];
                return romanticLastWords[Math.floor(Math.random() * romanticLastWords.length)];
            }
            
            if (bestFriendRel && Math.random() < 0.5) {
                const friend = bestFriendRel.character;
                const friendLastWords = [
                    `"Tell ${friend.name}... our friendship... meant everything..." - ${victim.name}, smiling weakly`,
                    `"${friend.name} will figure this out... they're too smart..." - ${victim.name}, confident`,
                    `"Don't hurt ${friend.name}... they're the best person I know..." - ${victim.name}, pleading`
                ];
                return friendLastWords[Math.floor(Math.random() * friendLastWords.length)];
            }
            
            if (familyRel && Math.random() < 0.5) {
                const family = familyRel.character;
                const familyLastWords = [
                    `"Keep ${family.name} safe... they're all I have left..." - ${victim.name}, desperate`,
                    `"Tell ${family.name}... I'm proud to be their family..." - ${victim.name}, peaceful`,
                    `"${family.name}... I'll see you again someday..." - ${victim.name}, hopeful`
                ];
                return familyLastWords[Math.floor(Math.random() * familyLastWords.length)];
            }
            
            // Fallback to campy archetype-specific final words
            return generateCampyDialogue(victim, 'death');
        }


        function addGroupEvent() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length < 2) return;
            
            const char1 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            const char2 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            const char3 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            
            const events = [
                `The group huddles in the living room. ${char1.name} suggests, "We should stick together!" ${char2.name} rolls their eyes. "Yeah, because that worked so well in every horror movie ever."`,
                `Everyone searches the house for clues. ${char1.name} finds a bloody hammer under the couch. "Uh, guys? This definitely wasn't here during our last Airbnb review."`,
                `${char1.name} starts nailing boards over the windows. "There!" they say proudly. ${char2.name} points out, "Congratulations, you just trapped us inside with the killer, genius."`,
                `A heated argument breaks out. ${char1.name} shouts, "One of us is the killer!" ${char2.name} snaps back, "Yeah, probably you for bringing it up!" ${char3.name} just wants to order pizza.`,
                `${char1.name} holds up their dead phone. "No bars. Classic." ${char2.name} tries the landline. "Cut. Also classic." ${char3.name} suggests, "Maybe we should have stayed home and stress-eaten ice cream instead."`,
                `The group finds a hidden camera in the bathroom. ${char1.name} waves at it sarcastically. "Hi Mom! If you're watching this, please send help and maybe some snacks!"`,
                `${char1.name} discovers all the car keys are missing. "Someone doesn't want us to leave." ${char2.name} tries to hotwire a car. "I learned this from Grand Theft Auto!" It doesn't work. "Apparently video games lied to me."`,
                `The group finds a creepy diary hidden in the attic. ${char1.name} reads aloud: "Day 47: They still don't suspect me." Everyone looks around suspiciously. "Well, that's not ominous at all," mutters ${char2.name}.`,
                `${char1.name} suggests they arm themselves with kitchen knives. ${char2.name} picks up a butter knife. "This should do it," they say sarcastically. ${char3.name} grabs a rolling pin. "I'm going full Great British Bake-Off on this killer."`,
                `Everyone decides to search different rooms. ${char1.name} points out, "Isn't splitting up how everyone dies in horror movies?" ${char2.name} shrugs, "We'll be fine. What could go wrong?" Famous last words.`,
                `${char1.name} finds a basement door that's been boarded up. "Should we check what's down there?" ${char2.name} responds, "Absolutely not! That's Horror 101: Never go in the basement! Have you learned nothing from scary movies?"`,
                `The group discovers strange symbols carved into the walls. ${char1.name} tries to take a photo but their camera won't work. "Great, even my phone knows this is cursed," they mutter.`,
                `${char1.name} notices all the mirrors in the house are covered. "That's not ominous at all," says ${char2.name}. ${char3.name} uncovers one and immediately screams at their own reflection. "False alarm! Just my terrible hair!"`,
                `Everyone realizes they can't remember how they got to this place. ${char1.name} says, "Last thing I remember was getting in the car..." ${char2.name} adds, "This feels like a really bad movie plot. Like, really bad."`,
                // Serious moments mixed in
                `The group sits in stunned silence, processing what they've witnessed. ${char1.name} finally speaks: "We're really going to die here, aren't we?" The weight of reality settles over them like a heavy blanket.`,
                `${char1.name} breaks down crying. "I just want to go home. I want to see my family again." ${char2.name} puts an arm around them. "We will. We have to believe that."`,
                // Special events for new archetypes
                ...(gameState.characters.some(c => c.archetype.name === 'The Reporter' && c.status === 'Alive') ? [
                    `${gameState.characters.find(c => c.archetype.name === 'The Reporter')?.name} starts taking notes. "This is going to make one hell of a story... if I survive to write it. 'Local Students Discover Murder is Bad for Health.'"`,
                    `${gameState.characters.find(c => c.archetype.name === 'The Reporter')?.name} tries to interview everyone. "Can you describe your feelings about possibly dying tonight? On a scale of one to ten, how would you rate this horror experience?"`,
                ] : []),
                ...(gameState.characters.some(c => c.archetype.name === 'The Horror Fanatic' && c.status === 'Alive') ? [
                    `${gameState.characters.find(c => c.archetype.name === 'The Horror Fanatic')?.name} excitedly explains, "This is exactly like my favorite slasher! We need to follow the survival rules! Step one: don't be stupid!"`,
                    `${gameState.characters.find(c => c.archetype.name === 'The Horror Fanatic')?.name} starts listing horror movie tropes. "Don't say 'I'll be right back,' don't investigate strange noises, and never, EVER split up! Also, avoid having sex because that's basically a death sentence!"`,
                ] : [])
            ];
            
            addEvent('event', events[Math.floor(Math.random() * events.length)]);
        }


        function addRedHerring() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length === 0) return;
            
            const character = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            
            const herrings = [
                `${character.name} is found with a bloody knife - but claims it's not what it looks like.`,
                `A witness claims they saw ${character.name} at the crime scene.`,
                `${character.name}'s alibi doesn't check out for the time of the murder.`,
                `${character.name} has a dark secret from their past that could be a motive.`,
                `${character.name} was acting strangely before the first murder occurred.`,
                `${character.name} is discovered burning bloody clothes in the backyard.`,
                `Someone finds ${character.name}'s fingerprints on the murder weapon.`,
                `${character.name} was overheard making threats against the victim last week.`,
                `A bloody handprint matching ${character.name}'s size is found at the scene.`,
                `${character.name} lied about where they were during the time of death.`,
                `${character.name} is caught sneaking around the house at night.`,
                `A love letter from ${character.name} is found in the victim's room... covered in blood.`,
                `${character.name} knows suspiciously detailed information about how the victim died.`,
                `Security footage shows ${character.name} near the victim's location before the murder.`,
                `${character.name} has the same type of weapon that killed the victim hidden in their bag.`
            ];
            
            addEvent('red-herring', herrings[Math.floor(Math.random() * herrings.length)]);
        }


        function addCharacterMoment() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length < 2) return;
            
            // Try to find characters with relationships first
            const romanticCouples = findCharactersByRelationType(relationshipTypes.ROMANTIC)
                .filter(pair => pair[0].status === 'Alive' && pair[1].status === 'Alive');
            const bestFriends = findCharactersByRelationType(relationshipTypes.BEST_FRIENDS)
                .filter(pair => pair[0].status === 'Alive' && pair[1].status === 'Alive');
            const enemies = findCharactersByRelationType(relationshipTypes.ENEMIES)
                .filter(pair => pair[0].status === 'Alive' && pair[1].status === 'Alive');
            const family = findCharactersByRelationType(relationshipTypes.FAMILY)
                .filter(pair => pair[0].status === 'Alive' && pair[1].status === 'Alive');
            
            let char1, char2, relationshipType = null;
            
            // 70% chance to use existing relationships if available
            if (Math.random() < 0.7) {
                if (romanticCouples.length > 0 && Math.random() < 0.4) {
                    [char1, char2] = romanticCouples[Math.floor(Math.random() * romanticCouples.length)];
                    relationshipType = 'romantic';
                } else if (bestFriends.length > 0 && Math.random() < 0.3) {
                    [char1, char2] = bestFriends[Math.floor(Math.random() * bestFriends.length)];
                    relationshipType = 'friends';
                } else if (enemies.length > 0 && Math.random() < 0.2) {
                    [char1, char2] = enemies[Math.floor(Math.random() * enemies.length)];
                    relationshipType = 'enemies';
                } else if (family.length > 0 && Math.random() < 0.3) {
                    [char1, char2] = family[Math.floor(Math.random() * family.length)];
                    relationshipType = 'family';
                }
            }
            
            // Fallback to random characters if no relationships used
            if (!char1 || !char2) {
                char1 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
                do {
                    char2 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
                } while (char2 === char1 && aliveChars.length > 1);
                
                // Check what relationship they actually have
                const relationship = getRelationship(char1, char2);
                if (relationship) {
                    if (relationship.type === relationshipTypes.ROMANTIC) relationshipType = 'romantic';
                    else if (relationship.type === relationshipTypes.BEST_FRIENDS) relationshipType = 'friends';
                    else if (relationship.type === relationshipTypes.ENEMIES) relationshipType = 'enemies';
                    else if (relationship.type === relationshipTypes.FAMILY) relationshipType = 'family';
                }
            }
            
            const moments = getRelationshipSpecificMoments(char1, char2, relationshipType);
            
            const selectedMoment = moments[Math.floor(Math.random() * moments.length)];
            addEvent('event', selectedMoment.event);
            selectedMoment.dialogue.forEach(line => {
                addEvent('dialogue', line);
            });
        }


        function getRelationshipSpecificMoments(char1, char2, relationshipType) {
            const deadFriend = gameState.characters.find(c => c.status === 'Dead');
            
            // Relationship-specific moments
            const relationshipMoments = {
                romantic: [
                    {
                        event: `💕 ${char1.name} and ${char2.name} find a quiet moment together despite the terror.`,
                        dialogue: [
                            `"I'm scared, ${char2.name}. What if we don't make it out of here?" - ${char1.name}, voice trembling.`,
                            `"Hey, look at me. We're going to be okay. I promise." - ${char2.name}, taking their hand.`,
                            `"I should have told you this before, but... I love you more than anything." - ${char1.name}`,
                            `"I love you too. And that's exactly why we're both going to survive this nightmare." - ${char2.name}`
                        ]
                    },
                    {
                        event: `💕 ${char1.name} and ${char2.name} make plans for their future together.`,
                        dialogue: [
                            `"When we get out of here, let's go somewhere far away." - ${char1.name}`,
                            `"Anywhere you want. Just the two of us." - ${char2.name}`,
                            `"I want to wake up next to you every day and forget this nightmare ever happened." - ${char1.name}`,
                            `"We will. I promise we will." - ${char2.name}, holding them close.`
                        ]
                    }
                ],
                friends: [
                    {
                        event: `👥 Best friends ${char1.name} and ${char2.name} rely on their bond to stay strong.`,
                        dialogue: [
                            `"We've been through everything together. We can survive this too." - ${char1.name}`,
                            `"Remember when we thought failing chemistry was the worst thing ever?" - ${char2.name}`,
                            `"God, we were so naive. I'd take a thousand chemistry exams over this." - ${char1.name}`,
                            `"At least we're facing it together. Best friends till the end." - ${char2.name}`
                        ]
                    },
                    {
                        event: `👥 ${char1.name} and ${char2.name} share childhood memories to stay calm.`,
                        dialogue: [
                            `"Remember our sleepovers when we'd stay up all night watching horror movies?" - ${char1.name}`,
                            `"And we'd laugh at how stupid the victims were for making bad decisions." - ${char2.name}`,
                            `"Well, this is awkward. We're literally living in one now." - ${char1.name}`,
                            `"At least we know all the rules. Stick together, don't split up, don't investigate strange noises." - ${char2.name}`
                        ]
                    }
                ],
                enemies: [
                    {
                        event: `⚔️ Old tensions flare between ${char1.name} and ${char2.name} even in the face of danger.`,
                        dialogue: [
                            `"I can't believe I have to rely on YOU to survive this." - ${char1.name}, disgusted.`,
                            `"Trust me, the feeling is mutual. But I'd rather work with you than die." - ${char2.name}`,
                            `"Fine. Temporary truce. But when this is over, we go back to hating each other." - ${char1.name}`,
                            `"Deal. Now can we focus on not dying?" - ${char2.name}, rolling their eyes.`
                        ]
                    },
                    {
                        event: `⚔️ ${char1.name} and ${char2.name}'s rivalry threatens to split the group.`,
                        dialogue: [
                            `"I'm not following any plan that involves trusting ${char2.name}!" - ${char1.name}`,
                            `"Oh, that's rich coming from someone who stabbed me in the back last year!" - ${char2.name}`,
                            `"That was different and you know it!" - ${char1.name}`,
                            `"Different? You cost me my scholarship! I'll never forgive you for that!" - ${char2.name}`
                        ]
                    }
                ],
                family: [
                    {
                        event: `👪 Family members ${char1.name} and ${char2.name} draw strength from their bond.`,
                        dialogue: [
                            `"Mom and Dad would be so proud of how strong you're being." - ${char1.name}`,
                            `"We have to protect each other. We're all the family we have left here." - ${char2.name}`,
                            `"Remember what Dad always said? 'Family sticks together no matter what.'" - ${char1.name}`,
                            `"No matter what. I won't let anything happen to you." - ${char2.name}, determined.`
                        ]
                    }
                ]
            };
            
            // Return relationship-specific moments or fall back to general moments
            if (relationshipType && relationshipMoments[relationshipType]) {
                return relationshipMoments[relationshipType];
            }
            
            // Fallback to campy dialogue moments
            return [
                {
                    event: `${char1.name} and ${char2.name} try to process the situation.`,
                    dialogue: [
                        generateCampyDialogue(char1, 'terrified'),
                        generateCampyDialogue(char2, 'terrified'),
                        generateCampyDialogue(char1, 'suspicious'),
                        generateCampyDialogue(char2, 'death')
                    ]
                }
            ];
        }


        function addTensionMoment() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length === 0) return;
            
            const character = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            
            const tensionMoments = [
                `${character.name} hears footsteps above them but when they call out, only silence answers.`,
                `${character.name} finds a window that was definitely closed before, now standing wide open.`,
                `${character.name} notices their reflection in a mirror... but there's a shadow behind them that shouldn't be there.`,
                `${character.name} feels like they're being watched, constantly looking over their shoulder.`,
                `${character.name} finds a note that simply says "YOU'RE NEXT" written in what looks like blood.`,
                `${character.name} hears their name being whispered from somewhere in the house.`,
                `${character.name} discovers that someone has been going through their personal belongings.`,
                `${character.name} finds muddy footprints leading from the back door to their bedroom.`,
                `${character.name} notices that all the family photos in the house have had the eyes scratched out.`,
                `${character.name} realizes that someone has been eating their food while they were sleeping.`
            ];
            
            const tensionDialogue = [
                `"Did anyone else hear that, or am I having a stress-induced hallucination?" - ${character.name}, voice shaking.`,
                `"I'm starting to think we're not alone in this house. Also, water is wet." - ${character.name}`,
                `"Something is very, very wrong here. Like, Netflix-canceling-your-favorite-show wrong." - ${character.name}`,
                `"I have the worst feeling that we're being played with like mice by a very psychotic cat." - ${character.name}`,
                `"This is psychological torture. The killer wants us scared... and honestly? Mission accomplished." - ${character.name}`,
                `"Is it just me, or does this feel like we're in a really twisted game show?" - ${character.name}`,
                `"I keep waiting for someone to jump out and say 'gotcha!' but I'm starting to think this is real." - ${character.name}`,
                `"Every horror movie I've ever watched is now feeling like a documentary." - ${character.name}`,
                `"I'm getting major final destination vibes and I don't like it." - ${character.name}`,
                `"Someone is definitely messing with us. The question is: how psychotic are they?" - ${character.name}`
            ];
            
            addEvent('event', tensionMoments[Math.floor(Math.random() * tensionMoments.length)]);
            addEvent('dialogue', generateCampyDialogue(character, 'terrified'));
        }


        function addCharacterInteraction() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length < 2) return;
            
            const char1 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            let char2 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            while (char2 === char1 && aliveChars.length > 1) {
                char2 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            }
            
            const deadFriend = gameState.characters.find(c => c.status === 'Dead');
            const killer = gameState.killers[0];
            
            const interactions = [
                {
                    event: `${char1.name} pulls ${char2.name} aside for a private conversation.`,
                    dialogue: [
                        `"${char2.name}, I need to tell you something about ${deadFriend?.name || 'what happened'}." - ${char1.name}, whispering urgently.`,
                        `"What is it? You're scaring me." - ${char2.name}`,
                        `"I saw someone in a black hoodie near ${deadFriend?.name || 'the victim'}'s room right before... you know." - ${char1.name}`,
                        `"Did you see their face?" - ${char2.name}, gripping ${char1.name}'s arm.`,
                        `"No, but they were tall... like ${killer.name} tall." - ${char1.name}, suspicious.`
                    ]
                },
                {
                    event: `${char1.name} and ${char2.name} search through ${deadFriend?.name || 'the victim'}'s belongings for clues.`,
                    dialogue: [
                        `"Look at this text message... '${deadFriend?.name || 'victim'}, meet me in the basement at midnight.'" - ${char1.name}`,
                        `"Who's it from?" - ${char2.name}`,
                        `"Unknown number... but whoever sent this lured ${deadFriend?.name || 'them'} down there." - ${char1.name}`,
                        `"We need to tell the others about this." - ${char2.name}, grabbing the phone.`
                    ]
                },
                {
                    event: `${char1.name} confides their deepest fears to ${char2.name}.`,
                    dialogue: [
                        `"I keep having nightmares about ${deadFriend?.name || 'the victim'}. What if I'm next?" - ${char1.name}`,
                        `"Don't think like that. We're going to figure this out." - ${char2.name}`,
                        `"How can you be so sure? People are dying and we don't even know why!" - ${char1.name}`,
                        `"Because giving up means the killer wins. And I'm not ready to let that happen." - ${char2.name}`
                    ]
                }
            ];
            
            const selectedInteraction = interactions[Math.floor(Math.random() * interactions.length)];
            addEvent('event', selectedInteraction.event);
            selectedInteraction.dialogue.forEach(line => {
                addEvent('dialogue', line);
            });
        }


        function addRelationshipDrama() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length < 3) return;
            
            const char1 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            let char2 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            let char3 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            
            while (char2 === char1) char2 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            while (char3 === char1 || char3 === char2) char3 = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            
            const dramas = [
                {
                    event: `Tension erupts between ${char1.name}, ${char2.name}, and ${char3.name}.`,
                    dialogue: [
                        `"I can't believe you're bringing this up NOW! We're literally in a horror movie!" - ${char1.name}, exasperated.`,
                        `"When else am I supposed to talk about it? We might all be dead by morning! This could be my last chance!" - ${char2.name}`,
                        `"Can we please focus on not dying instead of your relationship drama? Save it for Jerry Springer!" - ${char3.name}`,
                        `"This IS about survival! Trust matters when there's a killer on the loose!" - ${char2.name}`,
                        `"You want to talk about trust? Let's talk about what happened at Jake's party and my missing vape!" - ${char1.name}`
                    ]
                },
                {
                    event: `${char1.name} accuses ${char2.name} of hiding something, while ${char3.name} tries to mediate.`,
                    dialogue: [
                        `"You've been acting weird all night, ${char2.name}. And not your usual weird. Like, suspicious weird." - ${char1.name}`,
                        `"Everyone's acting weird! We're in a literal nightmare situation!" - ${char2.name}`,
                        `"Guys, maybe we should calm down and remember we're all traumatized..." - ${char3.name}`,
                        `"No! I want answers. Why did you really come here tonight? And don't say 'for fun.'" - ${char1.name}`,
                        `"I came here for the same reason as everyone else! To hang out and NOT get murdered!" - ${char2.name}`,
                        `"Which was supposed to be the easy part of tonight!" - ${char1.name}, suspicious.`
                    ]
                },
                {
                    event: `Old grudges surface between the group as stress takes its toll.`,
                    dialogue: [
                        `"I never liked you anyway, ${char2.name}. This whole situation just proves I was right to avoid you." - ${char1.name}`,
                        `"Oh, that's rich coming from you! Miss 'I-talk-behind-everyone's-back!'" - ${char2.name}`,
                        `"Stop it, both of you! Fighting each other won't bring back ${gameState.characters.find(c => c.status === 'Dead')?.name || 'the dead'}!" - ${char3.name}`,
                        `"Maybe if ${char2.name} hadn't suggested we come to this cursed place..." - ${char1.name}`,
                        `"I didn't force anyone! You all chose to come! I didn't exactly advertise it as 'Murder Night!'" - ${char2.name}`
                    ]
                },
                // Serious dramatic moment
                {
                    event: `The stress finally breaks ${char1.name}, leading to an emotional confrontation.`,
                    dialogue: [
                        `"I can't take this anymore! Everyone's dead and we're just standing around arguing!" - ${char1.name}, breaking down.`,
                        `"${char1.name}, you need to breathe. We're all scared." - ${char2.name}, reaching out.`,
                        `"Scared? SCARED?! People are dying! Our friends are GONE!" - ${char1.name}, sobbing.`,
                        `"I know. I know. But we have to stick together or we'll all end up like them." - ${char2.name}, voice trembling.`,
                        `"What if we already are? What if we're all just walking corpses who don't know it yet?" - ${char1.name}, devastated.`
                    ]
                }
            ];
            
            const selectedDrama = dramas[Math.floor(Math.random() * dramas.length)];
            addEvent('event', selectedDrama.event);
            selectedDrama.dialogue.forEach(line => {
                addEvent('dialogue', line);
            });
        }


        function addJumpScare() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length === 0) return;
            
            const character = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            const scares = [
                `${character.name} jumps when a cat suddenly appears from behind the couch.`,
                `${character.name} screams when ${aliveChars[Math.floor(Math.random() * aliveChars.length)].name} taps them on the shoulder unexpectedly.`,
                `${character.name} nearly has a heart attack when the old house settles with a loud CREAK.`,
                `${character.name} shrieks when they see their own reflection in a darkened window.`,
                `${character.name} jumps out of their skin when the refrigerator's ice maker suddenly activates.`,
                `${character.name} screams when a tree branch scrapes against the window.`
            ];
            
            const scareDialogue = [
                `"Jesus Christ! You scared the hell out of me!" - ${character.name}`,
                `"My heart is literally going to explode! Like, literally!" - ${character.name}`,
                `"I think I just aged ten years and lost five pounds!" - ${character.name}`,
                `"That's it, I'm never watching horror movies again! This is too meta!" - ${character.name}`,
                `"False alarm! Just my imagination running wild like a caffeinated squirrel." - ${character.name}`,
                `"Note to self: invest in heart medication if I survive this." - ${character.name}`,
                `"I think I just experienced every emotion known to humanity in three seconds." - ${character.name}`,
                `"My fight-or-flight response just chose 'cry dramatically.'" - ${character.name}`,
                `"I'm going to need so much therapy after this. Like, ALL the therapy." - ${character.name}`,
                `"Well, that's going to haunt my dreams forever. Thanks for that." - ${character.name}`
            ];
            
            addEvent('event', scares[Math.floor(Math.random() * scares.length)]);
            addEvent('dialogue', generateCampyDialogue(character, 'terrified'));
        }


        function addQuietMoment() {
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            if (aliveChars.length === 0) return;
            
            const character = aliveChars[Math.floor(Math.random() * aliveChars.length)];
            const moments = [
                `${character.name} sits alone, staring out the window at the dark forest beyond.`,
                `${character.name} quietly examines old family photos on the mantelpiece.`,
                `${character.name} finds an old diary and reads entries from happier times.`,
                `${character.name} lights a candle, seeking comfort in the warm glow.`,
                `${character.name} curls up with a blanket, trying to feel safe for a moment.`,
                `${character.name} looks through their phone at photos of better times.`
            ];
            
            const quietDialogue = [
                `"I wonder if we'll ever feel normal again. Like, will I ever enjoy a peaceful shower?" - ${character.name}, softly.`,
                `"This feels like a nightmare I can't wake up from. I keep pinching myself but it's not working." - ${character.name}`,
                `"I miss when our biggest worry was passing finals and whether to get Starbucks or Dunkin'." - ${character.name}`,
                `"What I wouldn't give for a boring, ordinary day right now. Even a Monday would be amazing." - ${character.name}`,
                `"I hope our families know how much we love them. I should have called my mom more." - ${character.name}`,
                `"If I survive this, I'm definitely switching my major to something safer. Like library science." - ${character.name}`,
                `"I keep thinking about all the Netflix shows I'll never get to finish." - ${character.name}`,
                `"This is the worst group project ever. And I've had some bad ones." - ${character.name}`,
                `"I wonder if this is what characters in horror movies feel like before they become statistics." - ${character.name}`,
                `"Right now I'd trade anything for my biggest problem to be choosing what to wear tomorrow." - ${character.name}`
            ];
            
            addEvent('narrative', moments[Math.floor(Math.random() * moments.length)]);
            addEvent('dialogue', generateCampyDialogue(character, 'terrified'));
        }


        function addSequelReferences() {
            const returningChars = gameState.characters.filter(c => c.isReturning && c.status === 'Alive');
            if (returningChars.length === 0) return;
            
            const returner = returningChars[Math.floor(Math.random() * returningChars.length)];
            const aliveChars = gameState.characters.filter(c => c.status === 'Alive');
            const newbie = aliveChars.find(c => !c.isReturning) || aliveChars[0];
            
            const sequelMoments = [
                {
                    event: `${returner.name} shares their experience from the first movie with ${newbie.name}.`,
                    dialogue: [
                        `"I've been through this before. Trust me, it doesn't get easier." - ${returner.name}, grimly.`,
                        `"What do you mean, 'been through this before'?" - ${newbie.name}, confused.`,
                        `"Let's just say this isn't my first rodeo with homicidal maniacs." - ${returner.name}`,
                        `"Are you telling me this has happened to you BEFORE?!" - ${newbie.name}, incredulous.`,
                        `"Welcome to my nightmare sequel, kid. Try to keep up." - ${returner.name}`
                    ]
                },
                {
                    event: `${returner.name} has PTSD flashbacks about the previous murders.`,
                    dialogue: [
                        `"This place... it reminds me of last time. The same feeling of dread." - ${returner.name}, shaking.`,
                        `"Last time? What last time?" - ${newbie.name}`,
                        `"Different killer, same playbook. They all think they're so original." - ${returner.name}`,
                        `"You're freaking me out. How are you so calm about this?" - ${newbie.name}`,
                        `"Because panic got my friends killed last time. This time I'm ready." - ${returner.name}`
                    ]
                }
            ];
            
            const selectedMoment = sequelMoments[Math.floor(Math.random() * sequelMoments.length)];
            addEvent('event', selectedMoment.event);
            selectedMoment.dialogue.forEach(line => {
                addEvent('dialogue', line);
            });
        }


        function addDiscoveryEvent() {
            const discoveries = [
                'The group finds evidence that the killer has been watching them for weeks.',
                'A hidden camera is discovered in one of the bedrooms.',
                'Strange symbols are found carved into the walls.',
                'The phone lines have been cut - they\'re completely isolated.',
                'A diary is found revealing the killer\'s twisted plans.',
                'Photos of all the victims are discovered pinned to a wall with red X\'s marked over the dead ones.',
                'A collection of personal items from each victim is found in a creepy shrine.',
                'The group discovers a detailed floor plan of the house with escape routes blocked off.',
                'Hidden speakers are found throughout the house - someone has been listening to everything.',
                'A countdown timer is discovered with just hours remaining until "Phase 2."',
                'The basement reveals a makeshift torture chamber that\'s been prepared for weeks.',
                'Security monitors show the killer has been watching them since they arrived.',
                'A list of names is found with most crossed out - and the survivors\' names are still on it.',
                'The group finds evidence that this exact scenario has happened before with other victims.',
                'A hidden room behind a bookshelf contains detailed psychological profiles of everyone.',
                'The wifi router reveals the killer has been monitoring all their online activity.',
                'A fake ID and multiple identities are discovered - the killer isn\'t who they seem.',
                'Maps of the local area show all escape routes have been systematically blocked.'
            ];
            
            addEvent('event', discoveries[Math.floor(Math.random() * discoveries.length)]);
        }

        function selectAdaptiveVictim(aliveCharacters) {
            // Initialize killer memory if not exists
            if (!gameState.killerMemory) {
                gameState.killerMemory = {
                    successfulKills: [],
                    failedAttempts: [],
                    suspicionLevels: new Map(),
                    preferredTargets: new Set(),
                    adaptationLevel: 0
                };
            }
            
            const killerMemory = gameState.killerMemory;
            
            // Adaptation Strategy 1: Target characters with highest suspicion on killer
            const suspiciousCharacters = aliveCharacters.filter(char => {
                if (!char.memory) return false;
                const suspicion = char.memory.getMostSuspected();
                return suspicion && gameState.killers.some(killer => killer.id == suspicion.id) && suspicion.level > 0.3;
            });
            
            if (suspiciousCharacters.length > 0 && Math.random() < 0.4) {
                const target = suspiciousCharacters[Math.floor(Math.random() * suspiciousCharacters.length)];
                killerMemory.preferredTargets.add(target.id);
                return target;
            }
            
            // Adaptation Strategy 2: Target isolated characters (learned behavior)
            const isolatedCharacters = aliveCharacters.filter(char => {
                const relationships = getCharacterRelationships(char);
                const aliveRelationships = relationships.filter(rel => rel.character.status === 'Alive');
                return aliveRelationships.length <= 1;
            });
            
            if (isolatedCharacters.length > 0 && Math.random() < 0.3) {
                return isolatedCharacters[Math.floor(Math.random() * isolatedCharacters.length)];
            }
            
            // Adaptation Strategy 3: Avoid characters who have survived previous attacks
            const survivorsToAvoid = aliveCharacters.filter(char => 
                killerMemory.failedAttempts.some(attempt => attempt.victimId === char.id)
            );
            
            const preferredTargets = aliveCharacters.filter(char => 
                !survivorsToAvoid.includes(char) || Math.random() < 0.2 // 20% chance to still target survivors
            );
            
            if (preferredTargets.length > 0) {
                return preferredTargets[Math.floor(Math.random() * preferredTargets.length)];
            }
            
            // Fallback: random selection
            return aliveCharacters[Math.floor(Math.random() * aliveCharacters.length)];
        }
        
        function updateKillerMemory(victim, success, witness = null) {
            if (!gameState.killerMemory) {
                gameState.killerMemory = {
                    successfulKills: [],
                    failedAttempts: [],
                    suspicionLevels: new Map(),
                    preferredTargets: new Set(),
                    adaptationLevel: 0
                };
            }
            
            const killerMemory = gameState.killerMemory;
            
            if (success) {
                killerMemory.successfulKills.push({
                    victimId: victim.id,
                    victimArchetype: victim.archetype,
                    location: 'current_location',
                    witnessPresent: witness !== null,
                    act: gameState.currentAct,
                    timestamp: Date.now()
                });
                killerMemory.adaptationLevel += 0.1;
            } else {
                killerMemory.failedAttempts.push({
                    victimId: victim.id,
                    victimArchetype: victim.archetype,
                    escapeMethod: 'fought_back',
                    witnessPresent: witness !== null,
                    act: gameState.currentAct,
                    timestamp: Date.now()
                });
                killerMemory.adaptationLevel += 0.05; // Learn from failures too
            }
            
            // Killer becomes more strategic over time
            if (killerMemory.adaptationLevel > 0.5) {
                generateKillerAdaptationEvent();
            }
        }
        
        function generateKillerAdaptationEvent() {
            const adaptationEvents = [
                "🧠 KILLER EVOLUTION: The killer is learning from their mistakes, becoming more calculated.",
                "🧠 KILLER EVOLUTION: The killer begins targeting victims more strategically.",
                "🧠 KILLER EVOLUTION: The killer adapts their hunting patterns based on previous encounters.",
                "🧠 KILLER EVOLUTION: The killer becomes more aware of who suspects them.",
                "🧠 KILLER EVOLUTION: The killer starts avoiding witnesses and choosing better moments to strike."
            ];
            
            if (Math.random() < 0.8) { // 80% chance to show adaptation (increased visibility)
                const event = adaptationEvents[Math.floor(Math.random() * adaptationEvents.length)];
                addEvent('killer-evolution', event);
            }
        }


        function performRandomAttack() {
            const aliveCharacters = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            if (aliveCharacters.length === 0) return;
            
            // Killer adaptation: choose victim based on learned patterns
            const victim = selectAdaptiveVictim(aliveCharacters);
            const otherCharacters = gameState.characters.filter(c => c.status === 'Alive' && c !== victim && !gameState.killers.includes(c));
            const witness = otherCharacters.length > 0 ? otherCharacters[Math.floor(Math.random() * otherCharacters.length)] : null;
            
            const attackScenarios = [
                `${victim.name} is in the kitchen making a sandwich when WHAM! The killer appears and slashes them across the arm with a butcher knife. ${victim.name} grabs a frying pan and BONK! knocks the killer backwards, then runs screaming into the living room.`,
                `${victim.name} opens a closet door and the killer tumbles out like an overstuffed coat rack. They wrestle briefly before ${victim.name} knees them in the groin and bolts. "Sorry! Not sorry!"`,
                `The killer grabs ${victim.name} from behind in the hallway, but ${victim.name} throws their elbow back, connects with the killer's nose (CRUNCH!), and breaks free. Blood spatters everywhere.`,
                `${victim.name} is cornered in the basement. The killer swings a crowbar, missing their head by inches and embedding it in the wall. "Thanks for the workout!" ${victim.name} quips, diving behind some boxes.`,
                `The killer attacks ${victim.name} with garden shears by the back door, but ${victim.name} grabs a nearby gnome and hurls it at the killer's face. "Take that, you psycho!" They escape through the dog door.`,
                `${victim.name} is doing laundry when the killer jumps out of the washing machine. ${victim.name} throws detergent in their eyes and runs. "Clean up your act!" they yell over their shoulder.`,
                `The killer corners ${victim.name} in the garage, revving a chainsaw. ${victim.name} starts the lawnmower and has an epic power tool duel before escaping on the riding mower.`,
                `${victim.name} is trapped in the bathroom when the killer kicks down the door. ${victim.name} sprays them with toilet cleaner and climbs out the window. "That's for ruining my skincare routine!"`,
                `The killer attacks ${victim.name} with a baseball bat in the living room. ${victim.name} uses a couch cushion as a shield and counter-attacks with a lamp. "Home decorating can be dangerous!"`,
                `${victim.name} is studying when the killer tries to strangle them with an ethernet cable. ${victim.name} hits them with a thick textbook and runs. "Knowledge is power!" they shout.`,
                `The killer ambushes ${victim.name} in the pantry with a meat tenderizer. ${victim.name} throws flour in their face and escapes. "Looks like you're the one getting tenderized!"`,
                `${victim.name} is in the attic when the killer attacks with a pitchfork. ${victim.name} swings from a rope like Tarzan and kicks them through the floorboards. "Timber!"`,
                `The killer tries to push ${victim.name} down the stairs, but ${victim.name} grabs the banister and kicks them down instead. "Gravity's a bitch!" they call down.`,
                `${victim.name} is trapped in the hot tub when the killer appears with an electric cattle prod. ${victim.name} splashes them and short-circuits the weapon, then escapes. "Shocking behavior!"`
            ];
            
            const scenario = attackScenarios[Math.floor(Math.random() * attackScenarios.length)];
            addEvent('attack', `⚠️ ${scenario}`);
            
            const survivorLines = [
                `"${witness?.name || 'Someone'}! The killer just tried to turn me into human confetti!" - ${victim.name}, bleeding but alive.`,
                `"I always knew my self-defense classes would pay off! Eat that, murderer!" - ${victim.name}, adrenaline pumping.`,
                `"Note to self: next party, bring mace AND a rocket launcher!" - ${victim.name}, catching their breath.`,
                `"This is why I have trust issues! And why I'm switching to online shopping!" - ${victim.name}, hands shaking.`,
                `"I think I just used up all my luck for the next five years!" - ${victim.name}, looking around frantically.`,
                `"That was like a really violent episode of home improvement!" - ${victim.name}, wiping blood.`,
                `"I'm definitely writing a scathing Yelp review about this place!" - ${victim.name}, still in shock.`,
                `"Who knew gardening tools could be so terrifying?!" - ${victim.name}, breathing heavily.`,
                `"I survived! Take that, Final Destination!" - ${victim.name}, pumping their fist.`,
                `"My mom always said I was a fighter. Guess she was right!" - ${victim.name}, proud but terrified.`,
                `"I feel like I'm in a horror movie... oh wait, I AM in a horror movie!" - ${victim.name}, realizing.`,
                `"Someone needs to call 911... if anyone still has cell service!" - ${victim.name}, checking their phone.`,
                `"I'm never watching another slasher film after this!" - ${victim.name}, traumatized.`,
                `"Is it weird that I'm kind of proud of myself right now?" - ${victim.name}, conflicted.`,
                `"I think I pulled something during that fight. Do we have any ice?" - ${victim.name}, checking for injuries.`,
                `"Well, that's going to need therapy. Like, a LOT of therapy." - ${victim.name}, processing.`,
                `"I fought a serial killer and lived! That's definitely going on my resume!" - ${victim.name}, oddly excited.`,
                `"Mental note: learn karate. Also, buy pepper spray. And maybe a tank." - ${victim.name}, planning ahead.`,
                `"I can't wait to trauma-dump about this in therapy!" - ${victim.name}, surprisingly upbeat.`,
                `"That was more cardio than I've done all year!" - ${victim.name}, out of breath.`
            ];
            
            addEvent('dialogue', generateCampyDialogue(victim, 'attack'));
            
            attackCharacter(victim, gameState.currentAct);
            
            // Update killer memory - failed attack (victim survived)
            updateKillerMemory(victim, false, witness);
        }


        function endAct1() {
            addEvent('title', '🎭 END OF ACT 1 🎭');
            gameState.currentAct = 2;
            updateProgress();
            
            // Queue up Act 2 start
            gameState.storyQueue.push({
                type: 'function',
                func: () => startAct2(),
                delay: 2000
            });
            
            updateStoryStatus();
        }


        function startAct2() {
            // Clear the story queue and start fresh for Act 2
            gameState.storyQueue = [];
            gameState.currentStoryIndex = 0;
            
            // Queue up Act 2 events
            gameState.storyQueue.push({
                type: 'title',
                text: '🎬 ACT 2 - THE BODY COUNT RISES 🎬',
                delay: 1000
            });
            
            gameState.storyQueue.push({
                type: 'narrative',
                text: 'Paranoia sets in as the survivors realize the killer is among them...',
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateEdgicRatings(1),
                delay: 500
            });
            
            // Multiple kills and events for Act 2
            const aliveCount = gameState.characters.filter(c => c.status === 'Alive').length;
            const killsNeeded = Math.floor(aliveCount * 0.4);
            
            // Add character development and tension between kills
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateInvestigationEvent(),
                delay: 1800
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addTensionMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addQuietMoment(),
                delay: 1500
            });
            
            // Add potential sequel reference
            if (gameState.characters.some(c => c.isReturning)) {
                gameState.storyQueue.push({
                    type: 'function',
                    func: () => {
                        if (Math.random() < 0.4) addSequelReferences();
                    },
                    delay: 1500
                });
            }
            
            for (let i = 0; i < killsNeeded; i++) {
                gameState.storyQueue.push({
                    type: 'function',
                    func: () => {
                        if (Math.random() < 0.7) {
                            performRandomKill();
                        } else {
                            performRandomAttack();
                        }
                    },
                    delay: 2500
                });
                
                // Add character moments between kills
                if (i < killsNeeded - 1) {
                    gameState.storyQueue.push({
                        type: 'function',
                        func: () => addRelationshipDrama(),
                        delay: 2000
                    });
                    
                    gameState.storyQueue.push({
                        type: 'function',
                        func: () => addCharacterMoment(),
                        delay: 2000
                    });
                    
                    gameState.storyQueue.push({
                        type: 'function',
                        func: () => addTensionMoment(),
                        delay: 1500
                    });
                    
                    gameState.storyQueue.push({
                        type: 'function',
                        func: () => addJumpScare(),
                        delay: 1500
                    });
                }
            }
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addMajorReveal(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addCharacterInteraction(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addTensionMoment(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addQuietMoment(),
                delay: 1500
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => addRedHerring(),
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => endAct2(),
                delay: 1000
            });
            
            updateMovieControls();
            
            if (gameState.autoPlay) {
                playNextStoryEvent();
            } else {
                updateStoryStatus();
            }
        }


        function addMajorReveal() {
            const reveals = [
                'The killer\'s true identity is starting to become clear...',
                'A shocking connection between the victims is discovered.',
                'The motive for the killings is finally revealed.',
                'A survivor realizes they knew the killer all along.'
            ];
            
            addEvent('reveal', reveals[Math.floor(Math.random() * reveals.length)]);
        }


        function endAct2() {
            addEvent('title', '🎭 END OF ACT 2 🎭');
            gameState.currentAct = 3;
            updateProgress();
            
            // Generate edgic for Act 2
            generateEdgicRatings(2);
            
            // Queue up Act 3 start
            gameState.storyQueue.push({
                type: 'function',
                func: () => startAct3(),
                delay: 2000
            });
            
            updateStoryStatus();
        }


        function startAct3() {
            // Clear the story queue and start fresh for Act 3
            gameState.storyQueue = [];
            gameState.currentStoryIndex = 0;
            
            // Queue up Extended Act 3 events
            gameState.storyQueue.push({
                type: 'title',
                text: '🎬 ACT 3 - THE FINAL CONFRONTATION 🎬',
                delay: 1000
            });
            
            gameState.storyQueue.push({
                type: 'narrative',
                text: 'The house falls into an eerie silence. The few remaining survivors huddle together, knowing the end is near...',
                delay: 2000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateSurvivorReflections(),
                delay: 3000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateTensionBuildup(),
                delay: 4000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateSuspenseSequence(),
                delay: 4000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => revealKiller(),
                delay: 5000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateKillerBackstory(),
                delay: 6000   // Wait for reveal speech to complete
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateSurvivorReactions(),
                delay: 4000   // Wait for backstory
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateChaseSequence(),
                delay: 4000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => finalConfrontation(),
                delay: 4000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateFinalBattle(),
                delay: 4000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => generateEnding(),
                delay: 3000
            });
            
            gameState.storyQueue.push({
                type: 'function',
                func: () => {
                    // Wait a bit longer for all events to finish
                    setTimeout(() => {
                        gameState.movieComplete = true;
                        updateMovieControls();
                        updateStoryStatus();
                    }, 3000);
                },
                delay: 1000
            });
            
            updateMovieControls();
            
            if (gameState.autoPlay) {
                playNextStoryEvent();
            } else {
                updateStoryStatus();
            }
        }
        
        function generateSurvivorReflections() {
            if (gameState.movieComplete) return;
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            if (survivors.length === 0) return;
            
            addEvent('narrative', '💭 The survivors reflect on the nightmare they\'ve endured...');
            
            // Show only one reflection to avoid overlap
            if (survivors.length > 0) {
                const survivor = survivors[0];
                const reflections = [
                    `"I keep thinking about ${gameState.characters.find(c => c.status === 'Dead')?.name || 'everyone we lost'}... they didn't deserve this."`,
                    `"How did we not see this coming? The signs were all there..."`,
                    `"I can't stop shaking. Will this nightmare ever end?"`,
                    `"We have to survive this. For everyone who didn't make it."`,
                    `"I trusted them... How could I have been so blind?"`
                ];
                const reflection = reflections[Math.floor(Math.random() * reflections.length)];
                addEvent('dialogue', `${reflection} - ${survivor.name}, haunted`);
            }
        }
        
        function generateTensionBuildup() {
            const tensionEvents = [
                '🔇 The house creaks ominously. Every shadow seems to move.',
                '💨 A cold draft sweeps through the room, though all windows are closed.',
                '🕯️ The lights flicker and dim, casting eerie shadows on the walls.',
                '📱 Someone\'s phone buzzes with a text from a dead person\'s number.',
                '🚪 A door somewhere in the house slams shut on its own.',
                '👥 The survivors realize someone is missing from their group.',
                '🔍 Fresh blood is discovered on a doorknob that was just cleaned.',
                '📺 The TV turns on by itself, showing static that forms disturbing shapes.'
            ];
            
            const event = tensionEvents[Math.floor(Math.random() * tensionEvents.length)];
            addEvent('tension', event);
        }
        
        function generateSuspenseSequence() {
            
            const suspenseEvents = [
                'Strange footsteps echo through the hallway, getting closer with each step.',
                'Scratching sounds come from inside the walls, as if something is trying to claw its way out.',
                'The survivors hear their own voices calling from empty rooms - but none of them are speaking.',
                'A music box starts playing a childhood lullaby, its melody twisted and haunting.',
                'Heavy breathing can be heard through the vents, deliberate and menacing.',
                'Photographs of the survivors appear scattered on the floor, their faces crossed out in red.',
                'The house\'s security system activates, locking all exits. They are truly trapped.',
                'A trail of bloody handprints leads from the basement to the survivors\' hiding spot.'
            ];
            
            const event = suspenseEvents[Math.floor(Math.random() * suspenseEvents.length)];
            addEvent('suspense', `🌑 SUSPENSE: ${event}`);
        }
        


        function revealKiller() {
            if (gameState.movieComplete) return;
            
            // Debug: Make sure this function is being called
            console.log("revealKiller() function called");
            
            addEvent('narrative', '🎭 THE MOMENT OF TRUTH ARRIVES...');
            
            // Make sure we have killers
            if (!gameState.killers || gameState.killers.length === 0) {
                addEvent('reveal', '🎭 ERROR: No killer found!');
                return;
            }
            
            // Immediate reveal to ensure it shows up
            const killerNames = gameState.killers.map(k => k.name).join(' and ');
            addEvent('reveal', `🎭 THE KILLER IS REVEALED: ${killerNames}!`);
            
            // Add motive immediately too
            try {
                const motives = generateKillerMotive();
                addEvent('reveal', `💭 MOTIVE: ${motives}`);
            } catch (error) {
                addEvent('reveal', `💭 MOTIVE: Pure evil and madness.`);
            }
            
            // Then add speech with a delay
            setTimeout(() => {
                if (gameState.movieComplete) return;
                try {
                    const speech = generateKillerSpeech();
                    addEvent('dialogue', `"${speech}" - ${gameState.killers[0].name}`);
                } catch (error) {
                    addEvent('dialogue', `"You will all pay for what you've done!" - ${gameState.killers[0].name}`);
                }
            }, 2000);
        }


        function generateKillerMotive() {
            const victims = gameState.characters.filter(c => c.status === 'Dead' && !gameState.killers.includes(c));
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            const firstVictim = victims.find(v => v.deathAct === 1);
            const killerName = gameState.killers[0].name;
            
            const motives = [
                `${killerName} discovered that ${firstVictim?.name || 'the victim'} was responsible for spreading rumors that ruined their reputation and caused their family to disown them.`,
                `${killerName} blamed the group for their younger sibling's suicide after being bullied by the popular kids.`,
                `${killerName} was being blackmailed by ${firstVictim?.name || 'the victim'} who had evidence of a dark secret from their past.`,
                `${killerName} was seeking revenge for a car accident that killed their best friend, believing the victims were responsible.`,
                `${killerName} felt betrayed and abandoned by their so-called friends who never supported them when they needed it most.`
            ];
            
            return motives[Math.floor(Math.random() * motives.length)];
        }


        function generateKillerSpeech() {
            const speeches = [
                "You all thought you were so perfect, so untouchable. But I showed you the truth!",
                "Every cut, every scream was for my brother! You destroyed my family!",
                "This isn't a movie, it's real life. And in real life, the killer wins!",
                "You never even noticed me, did you? Well, you'll remember me now!",
                "I gave you all a chance to confess, but you chose to stay silent. Now you pay!",
                "The game was rigged from the start. You were never going to survive!",
                "You pathetic insects! You think your precious friendship can save you now?",
                "All those years of humiliation, of being ignored... THIS is my revenge!",
                "I am the shadow that follows, the nightmare that haunts! You cannot escape me!",
                "Your blood will paint these walls red! Justice demands sacrifice!",
                "I am become death, destroyer of your miserable little world!",
                "You laughed at me, mocked me, cast me aside! Now who's laughing?!",
                "Every breath you take from this moment on is borrowed time!",
                "I have become something beyond your comprehension - pure vengeance!",
                "You created this monster! Now face the consequences of your cruelty!",
                "Death is too good for you! But it's all I can offer in this fleeting life!",
                "I am the reckoning you never saw coming! The bill for your sins!",
                "Your screams are music to my ears! Symphony of suffering!",
                "I tried to be good, to fit in... but you showed me that evil is the only truth!",
                "Welcome to my masterpiece! Each death, a brushstroke in my art of revenge!"
            ];
            
            return speeches[Math.floor(Math.random() * speeches.length)];
        }
        
        function generateKillerBackstory() {
            const killer = gameState.killers[0];
            addEvent('narrative', `🎭 KILLER BACKSTORY: The truth about ${killer.name}...`);
            
            const backstories = [
                `${killer.name} was always the outcast, watching from the shadows as others lived the life they could never have.`,
                `Years of psychological abuse turned ${killer.name} into something twisted and vengeful.`,
                `${killer.name} was once just like the others, until a traumatic event shattered their sanity forever.`,
                `The signs were always there - the dead animals, the disturbing artwork, the cold stare. But nobody paid attention.`,
                `${killer.name} had been planning this for months, studying each victim's routines and weaknesses.`,
                `What started as harmless fantasies slowly consumed ${killer.name}'s mind until murder became an obsession.`
            ];
            
            const backstory = backstories[Math.floor(Math.random() * backstories.length)];
            addEvent('backstory', `📖 ${backstory}`);
            
            // Add psychological profile
            setTimeout(() => {
                const profiles = [
                    `Psychological Profile: ${killer.name} exhibits classic signs of antisocial personality disorder with psychopathic tendencies.`,
                    `Expert Analysis: ${killer.name} likely suffered severe childhood trauma, leading to a complete disconnect from empathy.`,
                    `Criminal Profile: ${killer.name} is an organized killer who planned each murder with meticulous detail.`,
                    `Psychiatric Evaluation: ${killer.name} shows no remorse and views their victims as objects rather than people.`
                ];
                const profile = profiles[Math.floor(Math.random() * profiles.length)];
                addEvent('analysis', `🧠 ${profile}`);
            }, 1500);
        }
        
        function generateSurvivorReactions() {
            if (gameState.movieComplete) return;
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            const killer = gameState.killers[0];
            
            addEvent('narrative', '😱 The survivors react to the killer reveal...');
            
            // Show only one reaction to avoid overlap
            if (survivors.length > 0) {
                const survivor = survivors[0];
                const reactions = [
                    `"${killer.name}?! But you were one of us! How could you do this to your friends?!"`,
                    `"I trusted you... I actually TRUSTED you! You sick monster!"`,
                    `"All this time... you were right there with us, pretending to be scared!"`,
                    `"You're insane! You need help! This isn't you!"`,
                    `"I should have known... there was always something off about you..."`,
                    `"You killed them... you killed all of them! WHY?!"`,
                    `"I'm going to make sure you pay for what you've done!"`,
                    `"How long have you been planning this? How long have you been lying to us?!"`
                ];
                
                const reaction = reactions[Math.floor(Math.random() * reactions.length)];
                addEvent('dialogue', `${reaction} - ${survivor.name}, shocked and betrayed`);
            }
        }
        
        function generateChaseSequence() {
            if (gameState.movieComplete) return;
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            const killer = gameState.killers[0];
            
            addEvent('narrative', '🏃‍♂️ THE FINAL CHASE: The survivors scatter as the killer pursues them!');
            
            const chaseEvents = [
                `${killer.name} chases ${survivors[0]?.name || 'a survivor'} through the house, smashing through doors and furniture.`,
                `The survivors split up - a classic horror movie mistake that plays right into the killer's hands.`,
                `${killer.name} corners ${survivors[1]?.name || 'a survivor'} in the basement, their screams echoing through the house.`,
                `A deadly game of cat and mouse unfolds as ${killer.name} systematically hunts down each hiding survivor.`,
                `The house becomes a death maze as ${killer.name} uses secret passages to appear behind unsuspecting victims.`,
                `${killer.name} cuts off all escape routes, turning the house into an inescapable trap.`
            ];
            
            // Only show one chase event to avoid overlap
            const chaseEvent = chaseEvents[Math.floor(Math.random() * chaseEvents.length)];
            addEvent('chase', `🏃 ${chaseEvent}`);
        }
        
        function generateFinalBattle() {
            if (gameState.movieComplete) return;
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            const killer = gameState.killers[0];
            
            if (survivors.length === 0) return;
            
            addEvent('narrative', '⚔️ THE FINAL BATTLE: The last survivors make their stand!');
            
            const finalSurvivor = survivors[Math.floor(Math.random() * survivors.length)];
            
            const battleEvents = [
                `${finalSurvivor.name} fights back with desperate fury, using anything they can find as a weapon.`,
                `The house becomes a battlefield as ${finalSurvivor.name} and ${killer.name} engage in mortal combat.`,
                `${finalSurvivor.name} discovers ${killer.name}'s weakness and uses it against them in a climactic showdown.`,
                `In a final act of courage, ${finalSurvivor.name} confronts ${killer.name} to save the other survivors.`,
                `The battle rages through multiple rooms, both combatants bloody and exhausted but refusing to give up.`
            ];
            
            const battleEvent = battleEvents[Math.floor(Math.random() * battleEvents.length)];
            addEvent('battle', `⚔️ ${battleEvent}`);
            
            // Final battle dialogue
            setTimeout(() => {
                const battleDialogue = [
                    `"This ends NOW! I won't let you hurt anyone else!"`,
                    `"You want to kill me? Come and try, you psychopath!"`,
                    `"I'm not going down without a fight!"`,
                    `"For everyone you murdered, I'm going to make you pay!"`,
                    `"You picked the wrong person to mess with!"`
                ];
                const dialogue = battleDialogue[Math.floor(Math.random() * battleDialogue.length)];
                addEvent('dialogue', `"${dialogue}" - ${finalSurvivor.name}, defiant`);
            }, 1000);
        }
        
        function generateEnding() {
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            const victims = gameState.characters.filter(c => c.status === 'Dead' && !gameState.killers.includes(c));
            const killer = gameState.killers[0];
            
            addEvent('narrative', '🎬 THE CLIMACTIC ENDING...');
            
            if (survivors.length === 0) {
                // Killer wins - total victory
                addEvent('ending', '💀 KILLER VICTORY: The house falls silent. Evil has triumphed completely.');
                addEvent('dialogue', `"Perfect... absolutely perfect. They never saw it coming." - ${killer.name}, satisfied`);
                addEvent('title', '🎬 THE END - EVIL WINS 🎬');
            } else if (survivors.length === 1) {
                // Final girl/guy ending
                const finalSurvivor = survivors[0];
                addEvent('ending', `🏆 FINAL SURVIVOR: ${finalSurvivor.name} emerges as the sole survivor of this nightmare.`);
                addEvent('dialogue', `"It's over... it's finally over. I survived, but at what cost?" - ${finalSurvivor.name}, traumatized`);
                addEvent('title', '🎬 THE END - SOLE SURVIVOR 🎬');
            } else {
                // Multiple survivors ending
                addEvent('ending', `✊ SURVIVORS: ${survivors.length} people survived the killing spree, scarred but alive.`);
                addEvent('dialogue', `"We made it... but we'll never be the same." - ${survivors[0].name}, haunted`);
                addEvent('title', '🎬 THE END - SURVIVORS 🎬');
            }
            
            // Statistics
            setTimeout(() => {
                addEvent('stats', `📊 FINAL STATISTICS:`);
                addEvent('stats', `💀 Total Deaths: ${victims.length}`);
                addEvent('stats', `✅ Survivors: ${survivors.length}`);
                // Fix archetype display - handle both string and object cases
                const killerArchetype = killer.archetype?.name || killer.archetype || 'Psycho Killer';
                addEvent('stats', `🔪 Killer: ${killer.name} (${killerArchetype})`);
                addEvent('stats', `🎬 Movie Rating: ${generateMovieRating(victims.length, survivors.length)}`);
                
                if (survivors.length > 0) {
                    addEvent('stats', `🏆 Survivors: ${survivors.map(s => s.name).join(', ')}`);
                }
                
                // Add weapon used
                if (killer.preferredWeapon && typeof killer.preferredWeapon === 'string') {
                    addEvent('stats', `⚔️ Murder Weapon: ${killer.preferredWeapon}`);
                } else {
                    const weapons = ['Kitchen Knife', 'Machete', 'Chainsaw', 'Baseball Bat', 'Garden Shears', 'Axe'];
                    const weapon = weapons[Math.floor(Math.random() * weapons.length)];
                    addEvent('stats', `⚔️ Murder Weapon: ${weapon}`);
                }
            }, 2000);
        }
        
        function generateMovieRating(deaths, survivors) {
            if (deaths >= 8) return "R-Rated Bloodbath";
            if (deaths >= 5) return "Violent Thriller";
            if (deaths >= 3) return "Suspenseful Horror";
            if (deaths >= 1) return "Mild Horror";
            return "Psychological Thriller";
        }


        function finalConfrontation() {
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            
            if (survivors.length === 0) {
                // Killer wins
                addEvent('reveal', '💀 THE KILLER WINS! No survivors remain...');
                addEvent('title', '🎬 THE END 🎬');
                gameState.movieComplete = true;
                generateEdgicRatings(3);
                return;
            }
            
            // Ensure at least one survivor dies in Act 3 for drama
            const survivorsToKill = Math.max(1, Math.floor(survivors.length * 0.4)); // Kill at least 1, up to 40% of remaining
            const survivorsToAttack = Math.min(survivors.length - survivorsToKill, 3); // Attack some others but don't kill them
            
            // Select victims for final deaths
            const shuffledSurvivors = [...survivors].sort(() => Math.random() - 0.5);
            const victimsToKill = shuffledSurvivors.slice(0, survivorsToKill);
            const victimsToAttack = shuffledSurvivors.slice(survivorsToKill, survivorsToKill + survivorsToAttack);
            
            // Final confrontation begins
            addEvent('event', 'The final confrontation erupts into chaos as the killer makes their last desperate stand!');
            
            // Kill some survivors during the battle
            victimsToKill.forEach((victim, index) => {
                const killer = gameState.killers[Math.floor(Math.random() * gameState.killers.length)];
                
                const finalKillScenarios = [
                    `${victim.name} heroically tries to protect the others but ${killer.name} catches them off guard and delivers a fatal blow!`,
                    `${victim.name} gets cornered during the chaos and ${killer.name} shows no mercy - another life claimed in the final battle!`,
                    `${victim.name} makes a brave last stand but ${killer.name} overpowers them in the brutal melee!`,
                    `${victim.name} almost escapes but ${killer.name} grabs them at the last second - their sacrifice won't be forgotten!`,
                    `${victim.name} fights valiantly but ${killer.name} strikes them down in the climactic struggle!`,
                    `${victim.name} tries to help a fallen friend and ${killer.name} takes advantage of their compassion - a tragic end!`,
                    `${victim.name} refuses to abandon the others and pays the ultimate price when ${killer.name} attacks!`
                ];
                
                const scenario = finalKillScenarios[Math.floor(Math.random() * finalKillScenarios.length)];
                addEvent('death', `💀 FINAL ACT DEATH: ${scenario}`);
                
                const finalWords = [
                    `"At least... the others... will make it..." - ${victim.name}, with their dying breath`,
                    `"Tell my family... I tried to be brave..." - ${victim.name}, fading away`,
                    `"Don't let... this be... for nothing..." - ${victim.name}, looking at the other survivors`,
                    `"I'm sorry... I couldn't... protect everyone..." - ${victim.name}, tears in their eyes`,
                    `"Make sure... they pay... for what they've done..." - ${victim.name}, determined to the end`,
                    `"It's up to you now... finish this..." - ${victim.name}, passing the torch`,
                    `"I'm not afraid... anymore..." - ${victim.name}, finding peace`,
                    `"Remember me... as I lived... not how I died..." - ${victim.name}, smiling weakly`
                ];
                
                addEvent('dialogue', generateCampyDialogue(victim, 'death'));
                killCharacter(victim, killer, 3);
                
                // Add reaction from other survivors
                const remainingSurvivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
                if (remainingSurvivors.length > 0) {
                    const reactor = remainingSurvivors[Math.floor(Math.random() * remainingSurvivors.length)];
                    const reactions = [
                        `"NO! ${victim.name}!" - ${reactor.name}, screaming in anguish`,
                        `"This has to stop! No more death!" - ${reactor.name}, filled with rage`,
                        `"${victim.name}, I won't let you die in vain!" - ${reactor.name}, determined`,
                        `"We have to end this madness NOW!" - ${reactor.name}, rallying the others`
                    ];
                    addEvent('dialogue', generateCampyDialogue(reactor, 'death'));
                }
                
                // Add relationship reactions
                setTimeout(() => {
                    addRelationshipReactions(victim, 'death');
                }, 1000);
            });
            
            // Attack but don't kill some other survivors
            victimsToAttack.forEach(victim => {
                const attackMethods = [
                    `${victim.name} is slashed across the chest during the fight but keeps going`,
                    `${victim.name} is thrown against the wall but struggles back to their feet`,
                    `${victim.name} is stabbed in the shoulder but refuses to give up`,
                    `${victim.name} takes a brutal hit but their determination keeps them fighting`,
                    `${victim.name} is knocked down but crawls back into the fray`
                ];
                const method = attackMethods[Math.floor(Math.random() * attackMethods.length)];
                addEvent('attack', `⚠️ ${method}!`);
                attackCharacter(victim, 3);
            });
            
            // Check if anyone is left to face the killer
            const finalSurvivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            
            if (finalSurvivors.length === 0) {
                // Everyone died - killer wins
                addEvent('reveal', '💀 THE KILLER WINS! All survivors have fallen in the final battle...');
                addEvent('title', '🎬 THE END - KILLER VICTORY 🎬');
                gameState.movieComplete = true;
                generateEdgicRatings(3);
                return;
            }
            
            // Final battle with remaining survivors
            const finalGirl = finalSurvivors.find(s => s.archetype.name === 'The Final Girl') || finalSurvivors[0];
            const killerName = gameState.killers[0].name;
            const otherSurvivor = finalSurvivors.find(s => s !== finalGirl);
            
            addEvent('event', `${finalGirl.name} faces ${killerName} in the ultimate showdown while standing over the bodies of the fallen!`);
            
            if (otherSurvivor) {
                addEvent('dialogue', `"This is for ${victimsToKill[0]?.name || 'everyone we lost'}!" - ${otherSurvivor.name}, backing up ${finalGirl.name}`);
            }
            addEvent('dialogue', `"You killed ${victimsToKill.map(v => v.name).join(' and ')}! This ends NOW!" - ${finalGirl.name}, furious and determined`);
            
            // Defeat killer
            defeatKiller(finalGirl);
        }


        function defeatKiller(survivor) {
            const methods = [
                'stabs the killer with their own weapon',
                'pushes the killer off a balcony',
                'sets the killer on fire',
                'shoots the killer with a hidden gun',
                'electrocutes the killer',
                'crushes the killer with heavy machinery'
            ];
            
            const method = methods[Math.floor(Math.random() * methods.length)];
            
            addEvent('event', `${survivor.name} ${method}!`);
            addEvent('dialogue', `"It's over..." - ${survivor.name}, breathing heavily`);
            addEvent('title', '🎬 THE END 🎬');
            gameState.movieComplete = true;
            
            // Kill the killers
            gameState.killers.forEach(killer => {
                killer.status = 'Dead';
                killer.actStatuses[3] = 'Killed';
                killer.killedBy = survivor.name;
                killer.deathAct = 3;
            });
            
            // Generate final edgic ratings
            generateEdgicRatings(3);
        }


        function generateEdgicRatings(act) {
            gameState.characters.forEach(character => {
                // Update actStatuses for dead characters in future acts
                if (character.status === 'Dead') {
                    for (let futureAct = character.deathAct + 1; futureAct <= 3; futureAct++) {
                        character.actStatuses[futureAct] = 'N/A';
                    }
                }
                
                if (character.status === 'Dead' && character.deathAct < act) {
                    character.edgic[act] = 'N/A';
                    return;
                }
                
                if (character.status === 'Dead' && character.deathAct === act) {
                    // Death episode gets high visibility - more dramatic ratings with varied tones, more OTT
                    const deathRatings = ['CP5', 'MOR5', 'MORP5', 'CPM5', 'OTTM4', 'CPN4', 'MORN4', 'OTT4', 'OTTN4', 'OTTP4', 'OTT3', 'OTTM3'];
                    character.edgic[act] = deathRatings[Math.floor(Math.random() * deathRatings.length)];
                    return;
                }
                
                if (character.actStatuses[act] === 'Attacked') {
                    // Attacked characters get moderate to high visibility with varied tones, some OTT for drama
                    const attackRatings = ['MOR4', 'CPP3', 'MOR3', 'CP3', 'MORP4', 'MORP3', 'CPN3', 'MORN3', 'OTT3', 'OTTM3', 'OTTN3', 'OTTP3'];
                    character.edgic[act] = attackRatings[Math.floor(Math.random() * attackRatings.length)];
                    return;
                }
                
                if (gameState.killers.includes(character)) {
                    // Killers need different edits depending on the act
                    if (act === 3) {
                        // Act 3: Killer reveal - MUST be dramatic NEGATIVE or MIXED visibility - NO POSITIVE EVER
                        const killerRevealRatings = ['OTTN5', 'OTTN5', 'CPN5', 'OTTM5', 'OTTM4', 'CPM5', 'MORN5', 'OTTN4', 'CPN4', 'CPM4', 'MORN4', 'OTTM3', 'CPN3'];
                        character.edgic[act] = killerRevealRatings[Math.floor(Math.random() * killerRevealRatings.length)];
                    } else {
                        // Act 1-2: Hidden killer - mix of ratings, occasionally negative/mixed for hints, some OTT for dramatic moments
                        const hiddenKillerRatings = ['MOR2', 'MOR3', 'UTR2', 'MORN2', 'CPM2', 'MOR1', 'MORN1', 'CPN2', 'UTRN2', 'MORM2', 'OTTM2', 'OTTN2', 'OTT2'];
                        character.edgic[act] = hiddenKillerRatings[Math.floor(Math.random() * hiddenKillerRatings.length)];
                    }
                    return;
                }
                
                // Final girl gets strong edits that build over time with positive/neutral tones
                if (character.archetype.name === 'The Final Girl') {
                    if (act === 1) {
                        const finalGirlEarly = ['CP3', 'MORP3', 'MOR3', 'CPP2', 'MORP2'];
                        character.edgic[act] = finalGirlEarly[Math.floor(Math.random() * finalGirlEarly.length)];
                    } else if (act === 2) {
                        const finalGirlMid = ['CP4', 'CPP3', 'MORP4', 'MOR4', 'CPP4'];
                        character.edgic[act] = finalGirlMid[Math.floor(Math.random() * finalGirlMid.length)];
                    } else {
                        const finalGirlEnd = ['CP5', 'CPP5', 'MORP5', 'CP4', 'CPP4'];
                        character.edgic[act] = finalGirlEnd[Math.floor(Math.random() * finalGirlEnd.length)];
                    }
                    return;
                }
                
                // Other main character archetypes get varied tones including some CP ratings
                if (character.archetype.name === 'The Hero' || character.archetype.name === 'The Best Friend' || character.archetype.name === 'The Boyfriend') {
                    const mainCharacterChance = Math.random();
                    if (mainCharacterChance < 0.4) { // 40% chance for CP rating
                        const mainCharCPRatings = ['CP3', 'CPP3', 'CPN2', 'CP2', 'CPM3', 'CPP2', 'CPN3'];
                        character.edgic[act] = mainCharCPRatings[Math.floor(Math.random() * mainCharCPRatings.length)];
                    } else {
                        const mainCharMORRatings = ['MOR3', 'MORP3', 'MOR4', 'MORN2', 'MORP2', 'MORM3'];
                        character.edgic[act] = mainCharMORRatings[Math.floor(Math.random() * mainCharMORRatings.length)];
                    }
                    return;
                }
                
                // Suspicious characters get more complex edits with negative/mixed tones, some OTT
                if (character.archetype.name === 'The Bad Boy' || character.archetype.name === 'The Outcast') {
                    const suspiciousRatings = ['CPM3', 'MORN3', 'CPN2', 'MOR3', 'MORN2', 'CPM2', 'MORM2', 'UTRN2', 'OTT2', 'OTTM2', 'OTTN2'];
                    character.edgic[act] = suspiciousRatings[Math.floor(Math.random() * suspiciousRatings.length)];
                    return;
                }
                
                // Comic relief and other light characters - mostly positive/neutral
                if (character.archetype.name === 'The Stoner' || character.archetype.name === 'The Party Girl') {
                    const comicRatings = ['MOR2', 'MORP2', 'UTR2', 'MOR1', 'UTRP2', 'MOR3', 'MORP1', 'UTRP1'];
                    character.edgic[act] = comicRatings[Math.floor(Math.random() * comicRatings.length)];
                    return;
                }
                
                // New archetypes - Reporter and Horror Fanatic get decent visibility with varied tones, some OTT
                if (character.archetype.name === 'The Reporter') {
                    const reporterRatings = ['MOR3', 'CPP3', 'MOR4', 'CP3', 'MORP3', 'CP2', 'MORP4', 'CPN2', 'OTT3', 'OTTP3', 'OTTM2'];
                    character.edgic[act] = reporterRatings[Math.floor(Math.random() * reporterRatings.length)];
                    return;
                }
                
                if (character.archetype.name === 'The Horror Fanatic') {
                    const fanRatings = ['MOR3', 'MORP3', 'MOR2', 'CP3', 'MORP4', 'CPP2', 'MORN2', 'CPM2', 'OTT2', 'OTTP2', 'OTTM3'];
                    character.edgic[act] = fanRatings[Math.floor(Math.random() * fanRatings.length)];
                    return;
                }
                
                // Early boot candidates - mix of tones but lower visibility
                if (character.archetype.name === 'The Flirt' || character.archetype.name === 'The Rich Girl' || character.archetype.name === 'The Drama Queen') {
                    const earlyBootRatings = ['MOR1', 'MOR2', 'UTR1', 'UTR2', 'MORN1', 'MORP2', 'UTRN1', 'UTRP1', 'MORM1'];
                    character.edgic[act] = earlyBootRatings[Math.floor(Math.random() * earlyBootRatings.length)];
                    return;
                }
                
                // Everyone else gets varied tones with MOR being most common, sprinkle in some OTT
                const regularRatings = ['MOR1', 'MOR2', 'MOR2', 'MOR3', 'UTR1', 'UTR2', 'MORP2', 'MORN2', 'UTRP1', 'UTRN1', 'MORM1', 'UTRM1', 'OTT1', 'OTT2', 'OTTP1', 'OTTN1', 'OTTM1'];
                character.edgic[act] = regularRatings[Math.floor(Math.random() * regularRatings.length)];
            });
        }


        // NEW STORY CONTROL FUNCTIONS
        function updateMovieControls() {
            const continueBtn = document.getElementById('continue-btn');
            const autoplayBtn = document.getElementById('autoplay-btn');
            const skipBtn = document.getElementById('skip-btn');
            const viewResultsBtn = document.getElementById('view-results-btn');
            
            if (gameState.movieComplete) {
                continueBtn.style.display = 'none';
                autoplayBtn.style.display = 'none';
                skipBtn.style.display = 'none';
                viewResultsBtn.style.display = 'inline-block';
            } else if (gameState.autoPlay) {
                continueBtn.style.display = 'none';
                autoplayBtn.textContent = 'Disable Autoplay';
                skipBtn.style.display = 'inline-block';
                viewResultsBtn.style.display = 'none';
            } else {
                continueBtn.style.display = 'inline-block';
                autoplayBtn.textContent = 'Enable Autoplay';
                skipBtn.style.display = 'inline-block';
                viewResultsBtn.style.display = 'none';
            }
        }


        function updateStoryStatus() {
            const statusDiv = document.getElementById('story-status');
            
            if (gameState.movieComplete) {
                statusDiv.textContent = 'Movie Complete! Click "View Final Results" to see the final tables.';
                statusDiv.style.color = '#4CAF50';
            } else if (gameState.isKillerMode && gameState.killerPlayer && document.getElementById('killer-action-area')?.innerHTML.includes('KILLER ACTIONS AVAILABLE')) {
                statusDiv.textContent = `🔪 KILLER TURN - Choose your next move as ${gameState.killerPlayer.name}`;
                statusDiv.style.color = '#ff4444';
            } else if (gameState.autoPlay) {
                statusDiv.textContent = `Autoplay Mode - Act ${gameState.currentAct} (${gameState.currentStoryIndex}/${gameState.storyQueue.length} events)`;
                statusDiv.style.color = '#ff4444';
            } else {
                statusDiv.textContent = `Manual Mode - Act ${gameState.currentAct} - Click "Continue Story" for next event (${gameState.currentStoryIndex}/${gameState.storyQueue.length})`;
                statusDiv.style.color = '#ccc';
            }
        }


        function continueStory() {
            createBeep(600, 0.05);
            if (gameState.currentStoryIndex < gameState.storyQueue.length) {
                playNextStoryEvent();
            } else {
                // Check if movie is complete
                if (gameState.movieComplete) {
                    updateMovieControls();
                }
                updateStoryStatus();
                
                // Check if we should offer killer actions
                if (gameState.isKillerMode && gameState.killerPlayer && !gameState.movieComplete) {
                    const aliveVictims = gameState.characters.filter(c => 
                        c.status === 'Alive' && c.id !== gameState.killerPlayer.id
                    );
                    
                    if (aliveVictims.length > 0 && Math.random() < 0.4) { // 40% chance to offer killer actions
                        showKillerActions();
                        document.getElementById('force-killer-action').style.display = 'inline-block';
                        document.getElementById('killer-help-text').style.display = 'block';
                        updateStoryStatus();
                    }
                }
            }
        }


        function playNextStoryEvent() {
            if (gameState.currentStoryIndex >= gameState.storyQueue.length) {
                // Story queue is empty
                updateStoryStatus();
                
                // Check if we should offer killer actions when queue is empty
                if (gameState.isKillerMode && gameState.killerPlayer && !gameState.movieComplete) {
                    const aliveVictims = gameState.characters.filter(c => 
                        c.status === 'Alive' && c.id !== gameState.killerPlayer.id
                    );
                    
                    if (aliveVictims.length > 0) {
                        showKillerActions();
                        document.getElementById('force-killer-action').style.display = 'inline-block';
                        document.getElementById('killer-help-text').style.display = 'block';
                        updateStoryStatus();
                    }
                }
                return;
            }
            
            const event = gameState.storyQueue[gameState.currentStoryIndex];
            
            if (event.type === 'function') {
                event.func();
            } else {
                addEvent(event.type, event.text);
            }
            
            gameState.currentStoryIndex++;
            updateStoryStatus();
            
            // Check for killer action opportunities during story progression
            if (gameState.isKillerMode && gameState.killerPlayer && !gameState.movieComplete) {
                const aliveVictims = gameState.characters.filter(c => 
                    c.status === 'Alive' && c.id !== gameState.killerPlayer.id
                );
                
                if (aliveVictims.length > 0) {
                    // Random chance to offer killer actions during story events
                    if (Math.random() < 0.3) { // 30% chance during story progression
                        setTimeout(() => {
                            showKillerActions();
                            document.getElementById('force-killer-action').style.display = 'inline-block';
                            document.getElementById('killer-help-text').style.display = 'block';
                            updateStoryStatus();
                        }, 1000);
                        return; // Don't auto-continue, wait for killer action
                    }
                }
            }
            
            if (gameState.autoPlay && gameState.currentStoryIndex < gameState.storyQueue.length) {
                setTimeout(() => playNextStoryEvent(), event.delay || 2000);
            }
        }


        function toggleAutoplay() {
            gameState.autoPlay = !gameState.autoPlay;
            createBeep(600, 0.05);
            updateMovieControls();
            updateStoryStatus();
            
            if (gameState.autoPlay && !gameState.movieComplete) {
                playNextStoryEvent();
            }
        }


        function skipToEnd() {
            createBeep(400, 0.1);
            // Process all remaining events instantly
            while (gameState.currentStoryIndex < gameState.storyQueue.length) {
                const event = gameState.storyQueue[gameState.currentStoryIndex];
                if (event.type === 'function') {
                    event.func();
                } else {
                    addEvent(event.type, event.text);
                }
                gameState.currentStoryIndex++;
            }
            
            // Skip to final act if not there yet
            if (gameState.currentAct === 1) {
                endAct1();
                skipAct2();
                skipAct3();
            } else if (gameState.currentAct === 2) {
                endAct2();
                skipAct3();
            } else if (gameState.currentAct === 3) {
                // Already in final act, just complete it
                gameState.movieComplete = true;
            }
            
            updateMovieControls();
            updateStoryStatus();
        }


        function skipAct2() {
            gameState.currentAct = 2;
            updateProgress();
            addEvent('title', '🎬 ACT 2 - THE BODY COUNT RISES 🎬');
            generateEdgicRatings(1);
            
            // Quick kills
            const aliveCount = gameState.characters.filter(c => c.status === 'Alive').length;
            const killsNeeded = Math.floor(aliveCount * 0.4);
            for (let i = 0; i < killsNeeded; i++) {
                performRandomKill();
            }
            
            endAct2();
        }


        function skipAct3() {
            gameState.currentAct = 3;
            updateProgress();
            addEvent('title', '🎬 ACT 3 - THE FINAL CONFRONTATION 🎬');
            generateEdgicRatings(2);
            revealKiller();
            finalConfrontation();
            gameState.movieComplete = true;
        }


        function viewResults() {
            createBeep(600, 0.1);
            showResults();
        }


        function recordMovieInFranchise() {
            // Create movie record
            // Calculate movie stats
            const deadCharacters = gameState.characters.filter(c => c.status === 'Dead' && !gameState.killers.includes(c));
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            const killerNames = gameState.killers.map(k => k.name);
            const firstVictim = deadCharacters.find(c => c.deathAct === 1);
            const finalVictim = deadCharacters.filter(c => c.deathAct === 3)[0];
            
            const movieRecord = {
                title: gameState.movieTitle,
                year: gameState.movieYear,
                setting: gameState.movieSetting,
                characters: {},
                deaths: deadCharacters.length,
                survivors: survivors.length,
                killers: killerNames,
                killerArchetype: gameState.killers[0]?.archetype?.name,
                firstVictim: firstVictim?.name,
                finalVictim: finalVictim?.name,
                allCharacters: gameState.characters.map(c => ({
                    name: c.name,
                    archetype: c.archetype.name,
                    status: gameState.killers.includes(c) ? 'Killer' : c.status,
                    deathAct: c.deathAct,
                    isReturning: c.isReturning || false
                }))
            };
            
            // Record each character's status in this movie
            gameState.characters.forEach(character => {
                let status;
                if (gameState.killers.includes(character)) {
                    status = 'Killer';
                } else if (character.status === 'Alive') {
                    status = 'Survived';
                } else {
                    status = 'Killed';
                }
                
                movieRecord.characters[character.name] = {
                    archetype: character.archetype.name,
                    status: status,
                    isReturning: character.isReturning || false
                };
                
                // Add to all characters map if not already there
                if (!franchiseHistory.allCharacters.has(character.name)) {
                    franchiseHistory.allCharacters.set(character.name, {
                        archetype: character.archetype.name,
                        appearances: []
                    });
                }
                
                // Add this movie appearance
                franchiseHistory.allCharacters.get(character.name).appearances.push({
                    movieIndex: franchiseHistory.movies.length,
                    status: status,
                    isReturning: character.isReturning || false
                });
            });
            
            // Add movie to franchise history
            franchiseHistory.movies.push(movieRecord);
        }


        function displayFranchiseHistory() {
            if (franchiseHistory.movies.length === 0) return;
            
            const container = document.createElement('div');
            container.className = 'franchise-history';
            container.innerHTML = `
                <h3>🎬 Franchise History</h3>
                <p style="color: #ccc; margin-bottom: 20px;">Track every character across all movies in the franchise. 🔁 indicates returning characters.</p>
                <table class="final-table" id="franchise-table">
                    <thead>
                        <tr>
                            <th>Character</th>
                            <th>Archetype</th>
                            ${franchiseHistory.movies.map((movie, index) => 
                                `<th style="min-width: 120px;">${movie.title}<br><small style="opacity: 0.7;">${movie.year}</small></th>`
                            ).join('')}
                        </tr>
                    </thead>
                    <tbody id="franchise-tbody"></tbody>
                </table>
            `;
            
            // Insert after edgic table
            const edgicTable = document.querySelector('.edgic-table');
            edgicTable.parentNode.insertBefore(container, edgicTable.nextSibling);
            
            const tbody = document.getElementById('franchise-tbody');
            
            // Sort characters by first appearance, then by name
            const sortedCharacters = Array.from(franchiseHistory.allCharacters.entries())
                .sort((a, b) => {
                    const aFirstMovie = a[1].appearances[0].movieIndex;
                    const bFirstMovie = b[1].appearances[0].movieIndex;
                    if (aFirstMovie !== bFirstMovie) {
                        return aFirstMovie - bFirstMovie;
                    }
                    return a[0].localeCompare(b[0]); // Sort by name if same movie
                });
            
            sortedCharacters.forEach(([characterName, characterData]) => {
                const row = document.createElement('tr');
                
                // Character name and archetype
                row.innerHTML = `
                    <td><strong>${characterName}</strong></td>
                    <td>${characterData.archetype}</td>
                `;
                
                // Status in each movie
                franchiseHistory.movies.forEach((movie, movieIndex) => {
                    const cell = document.createElement('td');
                    cell.style.textAlign = 'center';
                    cell.style.padding = '8px 4px';
                    
                    const appearance = characterData.appearances.find(app => app.movieIndex === movieIndex);
                    
                    if (appearance) {
                        let statusClass = '';
                        let statusText = appearance.status;
                        
                        if (appearance.status === 'Survived') {
                            statusClass = 'status-alive';
                        } else if (appearance.status === 'Killed') {
                            statusClass = 'status-dead';
                        } else if (appearance.status === 'Killer') {
                            statusClass = 'status-killer';
                        }
                        
                        // Show returning indicator more prominently
                        if (appearance.isReturning) {
                            cell.innerHTML = `
                                <span class="${statusClass}">${statusText}</span>
                                <br><small style="color: #4CAF50;">🔁 Returning</small>
                            `;
                        } else {
                            cell.innerHTML = `<span class="${statusClass}">${statusText}</span>`;
                        }
                    } else {
                        // Character not in this movie
                        cell.innerHTML = '<span class="status-n/a">—</span>';
                        cell.style.background = '#1a1a1a';
                        cell.style.opacity = '0.5';
                    }
                    
                    row.appendChild(cell);
                });
                
                tbody.appendChild(row);
            });
            
            // Add film summary table after franchise history
            displayFilmSummaryTable(container);
        }
        
        function displayFilmSummaryTable(franchiseContainer) {
            if (franchiseHistory.movies.length === 0) return;
            
            const summaryContainer = document.createElement('div');
            summaryContainer.className = 'film-summary-table';
            summaryContainer.style.marginTop = '30px';
            
            summaryContainer.innerHTML = `
                <h3>🎬 Film Synopsis</h3>
                <p style="color: #ccc; margin-bottom: 20px;">A brief summary of each film in the franchise.</p>
                <table class="final-table">
                    <thead>
                        <tr>
                            <th style="width: 200px;">Film</th>
                            <th style="width: 120px;">Horror Meter™</th>
                            <th>Synopsis</th>
                        </tr>
                    </thead>
                    <tbody id="film-summary-tbody"></tbody>
                </table>
            `;
            
            franchiseContainer.appendChild(summaryContainer);
            
            const tbody = document.getElementById('film-summary-tbody');
            
            franchiseHistory.movies.forEach((movie, index) => {
                const row = document.createElement('tr');
                
                const synopsis = generateFilmSynopsis(movie, index);
                const ratings = generateHorrorMeterRatings(movie, index);
                
                // Check if movie has custom synopsis
                const finalSynopsis = movie.customSynopsis || synopsis;
                
                row.innerHTML = `
                    <td>
                        <strong>${movie.title}</strong><br>
                        <small style="opacity: 0.7;">${movie.year}</small>
                    </td>
                    <td style="text-align: center; font-size: 0.85rem; line-height: 1.3;">
                        ${ratings}
                    </td>
                    <td style="font-size: 0.95rem; line-height: 1.4; position: relative;">
                        <div id="synopsis-text-${index}" style="margin-bottom: 10px;">
                            ${finalSynopsis}
                        </div>
                        <div id="synopsis-edit-${index}" style="display: none; margin-bottom: 10px;">
                            <textarea id="synopsis-textarea-${index}" style="width: 100%; min-height: 80px; background: #2a2a2a; color: #fff; border: 1px solid #555; padding: 8px; border-radius: 4px; font-size: 0.9rem; line-height: 1.4; resize: vertical;">${finalSynopsis}</textarea>
                        </div>
                        <div style="text-align: right; margin-top: 5px;">
                            <button id="edit-btn-${index}" onclick="editSynopsis(${index})" style="background: #444; color: #fff; border: 1px solid #666; padding: 4px 8px; border-radius: 3px; font-size: 0.8rem; cursor: pointer;">✏️ Edit</button>
                            <button id="save-btn-${index}" onclick="saveSynopsis(${index})" style="background: #4CAF50; color: #fff; border: 1px solid #4CAF50; padding: 4px 8px; border-radius: 3px; font-size: 0.8rem; cursor: pointer; display: none; margin-left: 5px;">💾 Save</button>
                            <button id="cancel-btn-${index}" onclick="cancelEditSynopsis(${index})" style="background: #f44336; color: #fff; border: 1px solid #f44336; padding: 4px 8px; border-radius: 3px; font-size: 0.8rem; cursor: pointer; display: none; margin-left: 5px;">❌ Cancel</button>
                        </div>
                    </td>
                `;
                
                tbody.appendChild(row);
            });
        }
        
        function editSynopsis(movieIndex) {
            const textDiv = document.getElementById(`synopsis-text-${movieIndex}`);
            const editDiv = document.getElementById(`synopsis-edit-${movieIndex}`);
            const editBtn = document.getElementById(`edit-btn-${movieIndex}`);
            const saveBtn = document.getElementById(`save-btn-${movieIndex}`);
            const cancelBtn = document.getElementById(`cancel-btn-${movieIndex}`);
            
            // Hide text, show textarea and save/cancel buttons
            textDiv.style.display = 'none';
            editDiv.style.display = 'block';
            editBtn.style.display = 'none';
            saveBtn.style.display = 'inline-block';
            cancelBtn.style.display = 'inline-block';
            
            // Focus on textarea
            const textarea = document.getElementById(`synopsis-textarea-${movieIndex}`);
            textarea.focus();
        }
        
        function saveSynopsis(movieIndex) {
            const textarea = document.getElementById(`synopsis-textarea-${movieIndex}`);
            const newSynopsis = textarea.value.trim();
            
            if (!newSynopsis) {
                alert('Synopsis cannot be empty.');
                return;
            }
            
            // Update the movie record in franchise history
            if (franchiseHistory.movies[movieIndex]) {
                franchiseHistory.movies[movieIndex].customSynopsis = newSynopsis;
            }
            
            // Update the display
            const textDiv = document.getElementById(`synopsis-text-${movieIndex}`);
            textDiv.innerHTML = newSynopsis;
            
            // Hide edit mode, show text mode
            cancelEditSynopsis(movieIndex);
            
            // Show success feedback
            const saveBtn = document.getElementById(`save-btn-${movieIndex}`);
            const originalText = saveBtn.innerHTML;
            saveBtn.innerHTML = '✅ Saved';
            setTimeout(() => {
                if (saveBtn) saveBtn.innerHTML = originalText;
            }, 2000);
        }
        
        function cancelEditSynopsis(movieIndex) {
            const textDiv = document.getElementById(`synopsis-text-${movieIndex}`);
            const editDiv = document.getElementById(`synopsis-edit-${movieIndex}`);
            const editBtn = document.getElementById(`edit-btn-${movieIndex}`);
            const saveBtn = document.getElementById(`save-btn-${movieIndex}`);
            const cancelBtn = document.getElementById(`cancel-btn-${movieIndex}`);
            const textarea = document.getElementById(`synopsis-textarea-${movieIndex}`);
            
            // Reset textarea to original value
            const movie = franchiseHistory.movies[movieIndex];
            if (movie) {
                const originalSynopsis = movie.customSynopsis || generateFilmSynopsis(movie, movieIndex);
                textarea.value = originalSynopsis;
            }
            
            // Show text, hide textarea and save/cancel buttons
            textDiv.style.display = 'block';
            editDiv.style.display = 'none';
            editBtn.style.display = 'inline-block';
            saveBtn.style.display = 'none';
            cancelBtn.style.display = 'none';
        }
        
        function generateFilmSynopsis(movie, filmNumber) {
            const isSequel = filmNumber > 0;
            const allCharacters = movie.allCharacters || [];
            const deadCharacters = allCharacters.filter(c => c.status === 'Dead');
            const survivors = allCharacters.filter(c => c.status === 'Alive');
            const firstVictim = allCharacters.find(c => c.deathAct === 1);
            
            // Setting definitions
            const settingMap = {
                'crimson-falls': {
                    location: "the isolated mountain town of Crimson Falls",
                    atmosphere: "where autumn mist clings to abandoned cabins"
                },
                'willowbrook': {
                    location: "the forgotten lakeside community of Willowbrook",
                    atmosphere: "where dark waters hold deadly secrets"
                },
                'ravenshollow': {
                    location: "the remote college town of Ravenshollow",
                    atmosphere: "where ivy-covered halls echo with screams"
                },
                'cedar-ridge': {
                    location: "the snowbound village of Cedar Ridge",
                    atmosphere: "where winter winds carry whispers of murder"
                },
                'driftwood-bay': {
                    location: "the sleepy coastal town of Driftwood Bay",
                    atmosphere: "where lighthouse beams reveal unspeakable horrors"
                },
                'harvest-moon': {
                    location: "the agricultural settlement of Harvest Moon",
                    atmosphere: "where cornfields hide more than just crops"
                },
                'shadowbrook': {
                    location: "the abandoned mining town of Shadowbrook",
                    atmosphere: "where old tunnels conceal fresh graves"
                }
            };
            
            const events = [
                "a weekend getaway", "a reunion party", "a camping trip", "a holiday celebration",
                "a bachelor party", "a graduation celebration", "a research expedition", 
                "a family gathering", "a spring break vacation", "a wedding weekend"
            ];
            
            // Use consistent setting for sequels or user's choice
            let setting;
            if (isSequel && franchiseHistory.movies.length > 0) {
                // Use same setting as first movie for consistency
                const firstMovieSetting = franchiseHistory.movies[0].setting;
                if (firstMovieSetting && typeof firstMovieSetting === 'object' && firstMovieSetting.type === 'custom') {
                    // Use custom setting from first movie
                    setting = {
                        location: firstMovieSetting.location,
                        atmosphere: firstMovieSetting.atmosphere
                    };
                } else if (firstMovieSetting && firstMovieSetting !== 'random' && settingMap[firstMovieSetting]) {
                    setting = settingMap[firstMovieSetting];
                } else {
                    // Fallback to random if first movie setting was random or invalid
                    const settingKeys = Object.keys(settingMap);
                    setting = settingMap[settingKeys[Math.floor(Math.random() * settingKeys.length)]];
                }
            } else {
                // For first movie, use user's choice or random
                if (movie.setting && typeof movie.setting === 'object' && movie.setting.type === 'custom') {
                    // Use custom setting
                    setting = {
                        location: movie.setting.location,
                        atmosphere: movie.setting.atmosphere
                    };
                } else if (movie.setting && movie.setting !== 'random' && settingMap[movie.setting]) {
                    setting = settingMap[movie.setting];
                } else {
                    // Random selection
                    const settingKeys = Object.keys(settingMap);
                    setting = settingMap[settingKeys[Math.floor(Math.random() * settingKeys.length)]];
                }
            }
            
            const event = events[Math.floor(Math.random() * events.length)];
            
            // Build concise atmospheric synopsis (3-4 sentences max)
            let synopsis = '';
            if (isSequel) {
                const returningCharacters = allCharacters.filter(c => c.isReturning);
                if (returningCharacters.length > 0) {
                    synopsis += `Years after surviving the bloodbath that terrorized ${setting.location}, ${returningCharacters.map(c => c.name).join(' and ')} believed the nightmare was finally over. `;
                }
                synopsis += `But evil never truly dies in ${setting.location}. `;
            } else {
                synopsis += `In ${setting.location}, ${setting.atmosphere}, `;
            }
            
            // Add the gathering
            const groupSize = allCharacters.length;
            if (groupSize <= 6) {
                synopsis += `${allCharacters.slice(0, 3).map(c => c.name).join(', ')} and their close friends arrive for ${event}, unaware that death is already stalking their every move. `;
            } else {
                synopsis += `${allCharacters.slice(0, 4).map(c => c.name).join(', ')} lead a group of ${groupSize} friends to ${setting.location} for ${event}, unaware that death is already stalking their every move. `;
            }
            
            // Add dramatic turning point without revealing killer
            if (firstVictim || movie.firstVictim) {
                const victim = firstVictim?.name || movie.firstVictim;
                synopsis += `The terror begins when ${victim} is brutally murdered, their screams piercing the night as a masked killer claims their first victim. `;
            } else {
                synopsis += `The slaughter begins without warning as a masked killer emerges from the shadows, hunger for blood driving their every move. `;
            }
            
            // Add final outcome based on survivors
            if (survivors.length === 0) {
                synopsis += `In a blood-soaked finale, the killer completes their masterpiece of carnage, leaving no soul alive to tell the tale.`;
            } else if (survivors.length === 1) {
                synopsis += `Only ${survivors[0].name} remains standing in the final confrontation, forever scarred by the horrors they've witnessed.`;
            } else {
                synopsis += `${survivors.slice(0, 2).map(c => c.name).join(' and ')} must band together for one final, desperate stand against the killer's reign of terror.`;
            }
            
            return synopsis;
        }
        
        function generateHorrorMeterRatings(movie, filmNumber) {
            const isSequel = filmNumber > 0;
            const deaths = movie.deaths || 0;
            const survivors = movie.survivors || 0;
            const totalCharacters = deaths + survivors;
            
            // Calculate base scores
            let criticsBase = 50;
            let audienceBase = 60;
            
            // Critics scoring factors
            if (isSequel) {
                criticsBase -= 15; // Critics often hate sequels
            }
            
            // Death count impact on critics (they prefer "artistic" horror)
            if (deaths <= 2) {
                criticsBase += 20; // "Psychological masterpiece"
            } else if (deaths >= 8) {
                criticsBase -= 10; // "Mindless gore"
            }
            
            // Survival rate impact on critics
            const survivalRate = survivors / totalCharacters;
            if (survivalRate === 0) {
                criticsBase -= 15; // "Nihilistic and hopeless"
            } else if (survivors === 1) {
                criticsBase += 10; // "Classic final girl trope done well"
            }
            
            // Audience scoring factors (they love carnage)
            if (deaths >= 6) {
                audienceBase += 15; // "Epic body count!"
            } else if (deaths <= 2) {
                audienceBase -= 20; // "Boring, not enough kills"
            }
            
            // Sequel impact on audience (they're more forgiving)
            if (isSequel) {
                audienceBase -= 5; // Slight drop but not as harsh as critics
            }
            
            // Add randomness for variety
            criticsBase += Math.floor(Math.random() * 30) - 15; // ±15 variation
            audienceBase += Math.floor(Math.random() * 20) - 10; // ±10 variation
            
            // Clamp scores between 10-95
            const criticsScore = Math.max(10, Math.min(95, criticsBase));
            const audienceScore = Math.max(15, Math.min(98, audienceBase));
            
            // Generate score colors
            const criticsColor = criticsScore >= 70 ? '#4CAF50' : criticsScore >= 40 ? '#FF9800' : '#F44336';
            const audienceColor = audienceScore >= 70 ? '#4CAF50' : audienceScore >= 40 ? '#FF9800' : '#F44336';
            
            return `
                <div style="margin-bottom: 8px;">
                    <strong style="color: ${criticsColor};">🎭 ${criticsScore}%</strong><br>
                    <small style="opacity: 0.8;">Critics</small>
                </div>
                <div>
                    <strong style="color: ${audienceColor};">🍿 ${audienceScore}%</strong><br>
                    <small style="opacity: 0.8;">Audience</small>
                </div>
            `;
        }


        function displayKillerReveal() {
            const container = document.getElementById('killer-reveal-section');
            const killerNames = gameState.killers.map(k => `${k.name} (${k.archetype.name})`).join(', ');
            
            container.innerHTML = `
                <div class="killer-reveal">
                    <h3>KILLER(S) REVEALED</h3>
                    <div style="font-size: 1.5rem; margin: 15px 0;">${killerNames}</div>
                    <div class="motive-text">The truth comes out in the final act...</div>
                </div>
            `;
        }


        function displayFinalBodyCount() {
            const tbody = document.getElementById('final-body-tbody');
            tbody.innerHTML = '';
            
            // Sort by death order (dead first, then alive)
            const sortedCharacters = [...gameState.characters].sort((a, b) => {
                if (a.status === 'Dead' && b.status === 'Alive') return 1;
                if (a.status === 'Alive' && b.status === 'Dead') return -1;
                if (a.deathAct && b.deathAct) return b.deathAct - a.deathAct;
                return 0;
            });
            
            sortedCharacters.forEach(character => {
                const row = document.createElement('tr');
                
                const finalStatus = gameState.killers.includes(character) ? 'Killer' : character.status;
                const statusClass = finalStatus === 'Killer' ? 'status-killer' : 
                                  finalStatus === 'Alive' ? 'status-alive' : 'status-dead';
                
                row.innerHTML = `
                    <td>${character.name}</td>
                    <td>${character.archetype.name}</td>
                    <td><span class="status-${character.actStatuses[1].toLowerCase()}">${character.actStatuses[1]}</span></td>
                    <td><span class="status-${character.actStatuses[2].toLowerCase()}">${character.actStatuses[2]}</span></td>
                    <td><span class="status-${character.actStatuses[3].toLowerCase()}">${character.actStatuses[3]}</span></td>
                    <td><span class="${statusClass}">${finalStatus}</span></td>
                    <td>${character.killedBy || 'N/A'}</td>
                `;
                
                tbody.appendChild(row);
            });
        }


        function showResults() {
            // Remove any existing franchise history table first
            const existingFranchiseTable = document.querySelector('.franchise-history');
            if (existingFranchiseTable) {
                existingFranchiseTable.remove();
            }
            
            // Record this movie in franchise history
            recordMovieInFranchise();
            
            document.getElementById('movie-screen').classList.add('hidden');
            document.getElementById('results-screen').classList.remove('hidden');
            
            document.getElementById('final-title').textContent = `${gameState.movieTitle} - Final Results`;
            
            displayKillerReveal();
            displayFinalBodyCount();
            displayEdgicAnalysis();
            displayFranchiseHistory();
        }


        function displayEdgicAnalysis() {
            const tbody = document.getElementById('edgic-tbody');
            tbody.innerHTML = '';
            
            // Sort by death order - those who died first at bottom
            const sortedCharacters = [...gameState.characters].sort((a, b) => {
                if (a.status === 'Dead' && b.status === 'Alive') return 1;
                if (a.status === 'Alive' && b.status === 'Dead') return -1;
                if (a.deathAct && b.deathAct) return b.deathAct - a.deathAct;
                return 0;
            });
            
            sortedCharacters.forEach(character => {
                const row = document.createElement('tr');
                
                row.innerHTML = `
                    <td>${character.name}</td>
                    <td>${character.archetype.name}</td>
                    <td><span class="edgic-cell ${getEdgicClass(character.edgic[1])}">${character.edgic[1]}</span></td>
                    <td><span class="edgic-cell ${getEdgicClass(character.edgic[2])}">${character.edgic[2]}</span></td>
                    <td><span class="edgic-cell ${getEdgicClass(character.edgic[3])}">${character.edgic[3]}</span></td>
                `;
                
                tbody.appendChild(row);
            });
            
            // Add edgic legend after the table
            addEdgicLegend();
        }


        function addEdgicLegend() {
            // Check if legend already exists
            if (document.querySelector('.edgic-legend')) return;
            
            const legendDiv = document.createElement('div');
            legendDiv.className = 'edgic-legend';
            legendDiv.style.marginTop = '20px';
            legendDiv.style.padding = '20px';
            legendDiv.style.background = '#2a2a2a';
            legendDiv.style.borderRadius = '8px';
            legendDiv.style.border = '1px solid #555';
            
            legendDiv.innerHTML = `
                <h4 style="color: #ff4444; margin-bottom: 15px; text-transform: uppercase;">📊 Edgic Rating Legend</h4>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                    <div>
                        <h5 style="color: #fff; margin-bottom: 10px;">Visibility Types:</h5>
                        <div style="margin-bottom: 8px;"><span class="edgic-cell edgic-cp" style="display: inline-block; width: 50px; margin-right: 10px;">CP</span> <strong>Complex Personality</strong> - Strategic, gets personal content</div>
                        <div style="margin-bottom: 8px;"><span class="edgic-cell edgic-mor" style="display: inline-block; width: 50px; margin-right: 10px;">MOR</span> <strong>Middle of the Road</strong> - Moderate screen time, balanced edit</div>
                        <div style="margin-bottom: 8px;"><span class="edgic-cell edgic-utr" style="display: inline-block; width: 50px; margin-right: 10px;">UTR</span> <strong>Under the Radar</strong> - Minimal screen time</div>
                        <div style="margin-bottom: 8px;"><span class="edgic-cell edgic-ott" style="display: inline-block; width: 50px; margin-right: 10px;">OTT</span> <strong>Over the Top</strong> - Dramatic, excessive reactions</div>
                        <div style="margin-bottom: 8px;"><span class="edgic-cell edgic-na" style="display: inline-block; width: 50px; margin-right: 10px;">N/A</span> <strong>Not Available</strong> - Character is dead</div>
                    </div>
                    <div>
                        <h5 style="color: #fff; margin-bottom: 10px;">Rating Scale:</h5>
                        <div style="margin-bottom: 8px;"><strong>1-5</strong> - Visibility level (1 = low, 5 = high)</div>
                        <div style="margin-bottom: 8px;"><strong>P</strong> - Positive tone (heroic, sympathetic)</div>
                        <div style="margin-bottom: 8px;"><strong>N</strong> - Negative tone (villainous, unsympathetic)</div>
                        <div style="margin-bottom: 8px;"><strong>M</strong> - Mixed tone (both positive and negative)</div>
                        <div style="margin-bottom: 8px;"><em>No letter</em> - Neutral tone</div>
                    </div>
                </div>
                <div style="margin-top: 15px; padding: 10px; background: rgba(255, 68, 68, 0.1); border-radius: 5px; font-size: 0.9rem; color: #ccc;">
                    <strong>Color Guide:</strong> 
                    <span style="color: #DDA0DD;">■</span> <strong>Positive (P)</strong> - Light purple/pink tones | 
                    <span style="color: #FFD700;">■</span> <strong>Neutral</strong> - Gold/teal tones | 
                    <span style="color: #9370DB;">■</span> <strong>Negative (N)</strong> - Dark purple/red tones | 
                    <span style="color: #8FBC8F;">■</span> <strong>Mixed (M)</strong> - Green tones
                    <br><strong>Examples:</strong> CP5 = Complex Personality with maximum visibility | MORN3 = Middle of the Road with negative tone and moderate visibility | UTRP1 = Under the radar with positive tone and minimal screen time
                </div>
            `;
            
            // Insert after the edgic table
            const edgicTable = document.querySelector('.edgic-table');
            edgicTable.appendChild(legendDiv);
        }


        function getEdgicClass(rating) {
            if (rating === 'N/A') return 'edgic-na';
            if (rating === 'DEAD') return 'edgic-dead';
            if (rating === 'INV') return 'edgic-inv';
            
            // Convert rating to lowercase for easier matching
            const lowerRating = rating.toLowerCase();
            
            // UTR ratings
            if (lowerRating.includes('utr')) {
                if (lowerRating.includes('p')) return 'edgic-utrp';
                if (lowerRating.includes('n')) return 'edgic-utrn';
                if (lowerRating.includes('m')) return 'edgic-utrm';
                return 'edgic-utr';
            }
            
            // MOR ratings
            if (lowerRating.includes('mor')) {
                if (lowerRating.includes('p')) return 'edgic-morp';
                if (lowerRating.includes('n')) return 'edgic-morn';
                if (lowerRating.includes('m')) return 'edgic-morm';
                return 'edgic-mor';
            }
            
            // CP ratings
            if (lowerRating.includes('cp')) {
                if (lowerRating.includes('p')) return 'edgic-cpp';
                if (lowerRating.includes('n')) return 'edgic-cpn';
                if (lowerRating.includes('m')) return 'edgic-cpm';
                return 'edgic-cp';
            }
            
            // OTT ratings
            if (lowerRating.includes('ott')) {
                if (lowerRating.includes('p')) return 'edgic-ottp';
                if (lowerRating.includes('n')) return 'edgic-ottn';
                if (lowerRating.includes('m')) return 'edgic-ottm';
                return 'edgic-ott';
            }
            
            // Fallback
            return 'edgic-inv';
        }


        function createSequel() {
            const survivors = gameState.characters.filter(c => c.status === 'Alive' && !gameState.killers.includes(c));
            
            if (survivors.length === 0) {
                alert('No survivors to continue the franchise! Maybe try a reboot instead?');
                return;
            }
            
            // Show survivor selection screen
            showSurvivorSelection(survivors);
        }
        
        function showSurvivorSelection(survivors) {
            // Hide results screen and show selection
            document.getElementById('results-screen').classList.add('hidden');
            
            // Create survivor selection screen
            const selectionScreen = document.createElement('div');
            selectionScreen.id = 'survivor-selection-screen';
            selectionScreen.innerHTML = `
                <div class="container">
                    <div class="header">
                        <h1>🎬 CREATE SEQUEL 🎬</h1>
                        <div class="subtitle">Configure your sequel and select returning survivors</div>
                        <div class="tagline">Their experience might just save them... or make them bigger targets</div>
                    </div>
                    
                    <div class="section">
                        <h2>Sequel Configuration</h2>
                        <div class="form-group">
                            <label for="sequel-title">Sequel Title</label>
                            <input type="text" id="sequel-title" value="${generateSequelTitle(gameState.movieTitle)}" placeholder="Enter sequel title...">
                        </div>
                        <div class="form-group">
                            <label for="sequel-year">Release Year</label>
                            <input type="number" id="sequel-year" min="1970" max="2030" value="${gameState.movieYear + 1}" placeholder="${gameState.movieYear + 1}">
                        </div>
                        <div class="form-group">
                            <label for="new-characters-count">Number of New Characters to Add</label>
                            <select id="new-characters-count">
                                <option value="2">2 new characters</option>
                                <option value="3">3 new characters</option>
                                <option value="4" selected>4 new characters</option>
                                <option value="5">5 new characters</option>
                                <option value="6">6 new characters</option>
                                <option value="7">7 new characters</option>
                                <option value="8">8 new characters</option>
                                <option value="9">9 new characters</option>
                                <option value="10">10 new characters</option>
                                <option value="12">12 new characters</option>
                                <option value="15">15 new characters</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="sequel-game-mode">Game Mode</label>
                            <select id="sequel-game-mode">
                                <option value="spectator">Spectator (Killer hidden)</option>
                                <option value="killer">Play as Killer</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="section">
                        <h2>Select Returning Survivors</h2>
                        <p style="color: #ccc; margin-bottom: 20px;">Choose which survivors will return with boosted stats and traumatic memories:</p>
                        <div id="survivor-selection-grid" class="cast-grid"></div>
                        <div style="text-align: center; margin-top: 30px;">
                            <button class="btn" onclick="confirmSurvivorSelection()">Create Sequel with Selected Survivors</button>
                            <button class="btn btn-secondary" onclick="cancelSurvivorSelection()">Cancel</button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.appendChild(selectionScreen);
            
            // Populate survivor selection grid
            const grid = document.getElementById('survivor-selection-grid');
            survivors.forEach((survivor, index) => {
                const card = document.createElement('div');
                card.className = 'character-card';
                card.innerHTML = `
                    <div class="character-header">
                        <div class="character-avatar">👤</div>
                        <div class="character-info">
                            <h3>${survivor.name}</h3>
                            <div class="archetype">${survivor.archetype.name}</div>
                        </div>
                    </div>
                    <div class="stats-grid">
                        ${Object.entries(survivor.stats).map(([stat, value]) => `
                            <div class="stat">
                                <div class="stat-label">${stat.charAt(0).toUpperCase() + stat.slice(1)}</div>
                                <div class="stat-bar">
                                    <div class="stat-fill" style="width: ${value * 10}%"></div>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                    <div class="survival-chance">
                        Current: ${survivor.survivalChance.toFixed(1)}%
                        <br><span style="color: #4CAF50;">Sequel: ${calculateSurvivalChance({
                            ...survivor.stats,
                            survival: Math.min(10, survivor.stats.survival + 2),
                            intelligence: Math.min(10, survivor.stats.intelligence + 1),
                            stealth: Math.min(10, survivor.stats.stealth + 1)
                        }).toFixed(1)}%</span>
                    </div>
                    <div style="text-align: center; margin-top: 15px;">
                        <label style="display: flex; align-items: center; justify-content: center; cursor: pointer;">
                            <input type="checkbox" id="survivor-${index}" checked style="margin-right: 10px; transform: scale(1.5);">
                            <span style="color: #4CAF50; font-weight: bold;">Return for Sequel</span>
                        </label>
                    </div>
                `;
                grid.appendChild(card);
            });
            
            // Store survivors data for later use
            window.availableSurvivors = survivors;
        }
        
        function confirmSurvivorSelection() {
            const selectedSurvivors = [];
            
            // Get selected survivors
            window.availableSurvivors.forEach((survivor, index) => {
                const checkbox = document.getElementById(`survivor-${index}`);
                if (checkbox && checkbox.checked) {
                    selectedSurvivors.push(survivor);
                }
            });
            
            if (selectedSurvivors.length === 0) {
                alert('You must select at least one survivor to return! Otherwise it\'s not really a sequel...');
                return;
            }
            
            // Get sequel configuration
            const sequelTitle = document.getElementById('sequel-title').value || generateSequelTitle(gameState.movieTitle);
            const sequelYear = parseInt(document.getElementById('sequel-year').value) || (gameState.movieYear + 1);
            const newCharactersCount = parseInt(document.getElementById('new-characters-count').value) || 4;
            const sequelGameMode = document.getElementById('sequel-game-mode').value;
            
            // Remove selection screen
            const selectionScreen = document.getElementById('survivor-selection-screen');
            if (selectionScreen) {
                selectionScreen.remove();
            }
            
            // Create sequel with selected survivors and configuration
            createSequelWithSurvivors(selectedSurvivors, sequelTitle, sequelYear, newCharactersCount, sequelGameMode);
        }
        
        function cancelSurvivorSelection() {
            // Remove selection screen and return to results
            const selectionScreen = document.getElementById('survivor-selection-screen');
            if (selectionScreen) {
                selectionScreen.remove();
            }
            document.getElementById('results-screen').classList.remove('hidden');
        }
        
        function createSequelWithSurvivors(selectedSurvivors, sequelTitle, sequelYear, newCharactersCount, sequelGameMode) {
            // Remove any existing franchise history table (will be recreated with updated data)
            const existingFranchiseTable = document.querySelector('.franchise-history');
            if (existingFranchiseTable) {
                existingFranchiseTable.remove();
            }
            
            // Inherit setting from previous movie for consistency
            const previousSetting = franchiseHistory.movies.length > 0 ? franchiseHistory.movies[0].setting : 'random';
            
            // Reset everything but keep selected survivors
            gameState = {
                characters: [],
                killers: [],
                gameMode: sequelGameMode,
                currentAct: 1,
                movieTitle: sequelTitle,
                movieYear: sequelYear,
                movieSetting: previousSetting,
                events: [],
                isKillerMode: sequelGameMode === 'killer',
                killerPlayer: null,
                autoPlay: false,
                movieComplete: false,
                storyQueue: [],
                currentStoryIndex: 0,
                relationships: new Map()
            };
            
            // Add selected survivors as returning characters with boosted stats
            selectedSurvivors.forEach((survivor, index) => {
                const returningSurvivor = {
                    ...survivor,
                    id: index,
                    status: 'Alive',
                    actStatuses: { 1: 'Alive', 2: 'Alive', 3: 'Alive' },
                    killedBy: null,
                    deathAct: null,
                    edgic: { 1: 'UTR1', 2: 'UTR1', 3: 'UTR1' },
                    isReturning: true
                };
                
                // Boost survivor stats (they learned from last time)
                returningSurvivor.stats.survival = Math.min(10, returningSurvivor.stats.survival + 2);
                returningSurvivor.stats.intelligence = Math.min(10, returningSurvivor.stats.intelligence + 1);
                returningSurvivor.stats.stealth = Math.min(10, returningSurvivor.stats.stealth + 1);
                returningSurvivor.survivalChance = calculateSurvivalChance(returningSurvivor.stats);
                
                // Create legacy memory system for returning survivors
                returningSurvivor.legacyMemory = {
                    previousMovieCount: (survivor.legacyMemory?.previousMovieCount || 0) + 1,
                    totalDeathsWitnessed: survivor.legacyMemory?.totalDeathsWitnessed || 0,
                    killersEncountered: survivor.legacyMemory?.killersEncountered || [],
                    survivalExperience: (survivor.legacyMemory?.survivalExperience || 0) + 1,
                    traumaticEvents: survivor.legacyMemory?.traumaticEvents || [],
                    trustedAllies: survivor.legacyMemory?.trustedAllies || [],
                    ptsdLevel: survivor.legacyMemory?.ptsdLevel || 0.2 // All survivors have some PTSD
                };
                
                // Add memories from the previous movie
                if (survivor.memory) {
                    returningSurvivor.legacyMemory.totalDeathsWitnessed += survivor.memory.witnessedDeaths.length;
                    returningSurvivor.legacyMemory.traumaticEvents.push({
                        movie: gameState.movieTitle || 'Previous Horror',
                        description: `Survived a killing spree`,
                        impact: 'high'
                    });
                }
                
                gameState.characters.push(returningSurvivor);
            });
            
            // Preserve relationships between returning survivors
            for (let i = 0; i < selectedSurvivors.length; i++) {
                for (let j = i + 1; j < selectedSurvivors.length; j++) {
                    const oldRel = getRelationship(selectedSurvivors[i], selectedSurvivors[j]);
                    if (oldRel) {
                        // Find the new character objects
                        const newChar1 = gameState.characters[i];
                        const newChar2 = gameState.characters[j];
                        
                        // Relationships may have evolved due to shared trauma
                        let newRelType = oldRel.type;
                        
                        // 30% chance relationships changed due to trauma
                        if (Math.random() < 0.3) {
                            if (oldRel.type === relationshipTypes.NEUTRAL) {
                                // Neutral relationships might become friendships through shared trauma
                                newRelType = relationshipTypes.BEST_FRIENDS;
                            } else if (oldRel.type === relationshipTypes.ENEMIES) {
                                // Enemies might put aside differences
                                newRelType = Math.random() < 0.7 ? relationshipTypes.NEUTRAL : relationshipTypes.BEST_FRIENDS;
                            } else if (oldRel.type === relationshipTypes.BEST_FRIENDS) {
                                // Best friends might become even closer (family-like bond)
                                newRelType = Math.random() < 0.4 ? relationshipTypes.FAMILY : relationshipTypes.BEST_FRIENDS;
                            }
                            // Romantic and family relationships usually stay the same
                        }
                        
                        createRelationship(newChar1, newChar2, newRelType);
                    }
                }
            }
            
            // Add new characters based on user selection
            const usedNames = new Set(selectedSurvivors.map(s => s.name));
            const usedArchetypes = new Set(selectedSurvivors.map(s => s.archetype.name));
            
            for (let i = 0; i < newCharactersCount; i++) {
                let name, archetype;
                
                // Get unique name
                do {
                    name = names[Math.floor(Math.random() * names.length)];
                } while (usedNames.has(name));
                usedNames.add(name);
                
                // Get unique archetype
                do {
                    archetype = archetypes[Math.floor(Math.random() * archetypes.length)];
                } while (usedArchetypes.has(archetype.name) && usedArchetypes.size < archetypes.length);
                usedArchetypes.add(archetype.name);
                
                const newCharacter = {
                    id: selectedSurvivors.length + i,
                    name: name,
                    archetype: archetype,
                    stats: { ...archetype.stats },
                    status: 'Alive',
                    actStatuses: { 1: 'Alive', 2: 'Alive', 3: 'Alive' },
                    killedBy: null,
                    deathAct: null,
                    survivalChance: calculateSurvivalChance(archetype.stats),
                    edgic: { 1: 'UTR1', 2: 'UTR1', 3: 'UTR1' },
                    isReturning: false
                };
                
                gameState.characters.push(newCharacter);
            }
            
            // Select new killers (survivors can't be killers in sequels - they've suffered enough)
            const newCharacters = gameState.characters.filter(c => !c.isReturning);
            const killerCount = Math.random() < 0.7 ? 1 : 2; // Sequels usually have 1-2 killers
            
            gameState.killers = [];
            const killerIndices = [];
            while (killerIndices.length < killerCount && newCharacters.length > 0) {
                const index = Math.floor(Math.random() * newCharacters.length);
                if (!killerIndices.includes(index)) {
                    killerIndices.push(index);
                    gameState.killers.push(newCharacters[index]);
                }
            }
            
            // Switch to setup screen
            document.getElementById('setup-screen').classList.remove('hidden');
            document.getElementById('cast-customization').classList.remove('hidden');
            
            // Update the movie title and year fields
            document.getElementById('movie-title').value = gameState.movieTitle;
            document.getElementById('movie-year').value = gameState.movieYear;
            document.getElementById('game-mode').value = gameState.gameMode;
            
            // Show sequel cast
            displayCastCustomization();
            
            // Show sequel message
            setTimeout(() => {
                alert(`🎬 SEQUEL CREATED! 🎬\n\n"${gameState.movieTitle}" (${gameState.movieYear})\n\nMode: ${gameState.gameMode === 'killer' ? 'Play as Killer' : 'Spectator'}\n${selectedSurvivors.length} selected survivor(s) return with boosted stats and ${newCharactersCount} new victims... I mean, characters!\n\nReturning characters are highlighted in green and have improved survival skills from their previous experience.${gameState.gameMode === 'killer' ? '\n\nYou can now select which character to play as the killer!' : ''}`);
            }, 500);
        }
        
        function generateSequelTitle(originalTitle) {
            const sequelFormats = [
                `${originalTitle} 2: The Return`,
                `${originalTitle} 2: Back for Blood`,
                `${originalTitle}: The Sequel`,
                `${originalTitle} II: Revenge`,
                `${originalTitle} 2: Electric Boogaloo`,
                `${originalTitle}: Still Screaming`,
                `${originalTitle} 2: The Reckoning`,
                `${originalTitle}: Resurrection`,
                `${originalTitle} 2: Final Chapter`,
                `${originalTitle}: Legacy`,
                `${originalTitle} 2: New Blood`,
                `${originalTitle}: Reloaded`,
                `Return to ${originalTitle}`,
                `${originalTitle}: The Next Level`,
                `${originalTitle} 2: Unfinished Business`
            ];
            
            return sequelFormats[Math.floor(Math.random() * sequelFormats.length)];
        }


        function resetSimulator() {
            createBeep(400, 0.1);
            gameState = {
                characters: [],
                killers: [],
                gameMode: 'spectator',
                currentAct: 1,
                movieTitle: '',
                movieYear: new Date().getFullYear(),
                events: [],
                isKillerMode: false,
                killerPlayer: null,
                autoPlay: false,
                movieComplete: false,
                storyQueue: [],
                currentStoryIndex: 0,
                relationships: new Map()
            };
            
            // Reset franchise history for completely new franchise
            franchiseHistory = {
                movies: [],
                allCharacters: new Map()
            };
            
            document.getElementById('results-screen').classList.add('hidden');
            document.getElementById('movie-screen').classList.add('hidden');
            document.getElementById('setup-screen').classList.remove('hidden');
            document.getElementById('cast-customization').classList.add('hidden');
            
            // Remove any relationship setup screen
            const relationshipSetup = document.getElementById('relationship-setup');
            if (relationshipSetup) {
                relationshipSetup.remove();
            }
            
            // Reset form values
            document.getElementById('movie-title').value = '';
            document.getElementById('movie-year').value = new Date().getFullYear();
            document.getElementById('game-mode').value = 'spectator';
            document.getElementById('cast-size').value = '8';
            document.getElementById('killer-count').value = 'random';
            
            // Clear logs
            document.getElementById('movie-log').innerHTML = '';
            
            // Remove any existing franchise history table
            const existingFranchiseTable = document.querySelector('.franchise-history');
            if (existingFranchiseTable) {
                existingFranchiseTable.remove();
            }
        }


        // Enhanced button effects
        document.addEventListener('click', function(e) {
            if (e.target.classList.contains('btn')) {
                createBeep(600, 0.05);
                addVisualEffect(e.target, 'pulse-effect', 200);
            }
        });


        // Initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            initAudioSystem();
            initAudioWidget();
            console.log('Slasher Movie Simulator with Relationship System loaded successfully!');
            
            // Enable audio context on first user interaction (required by browsers)
            const enableAudio = () => {
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                document.removeEventListener('click', enableAudio);
                document.removeEventListener('keydown', enableAudio);
            };
            document.addEventListener('click', enableAudio);
            document.addEventListener('keydown', enableAudio);
        });


        // Make sure these functions are globally accessible
        window.toggleAudioWidget = toggleAudioWidget;
        window.toggleAmbient = toggleAmbient;
        window.toggleSFX = toggleSFX;
        window.toggleMusic = toggleMusic;
        window.setMasterVolume = setMasterVolume;
        window.setupCast = setupCast;
        window.testRelationshipSystem = testRelationshipSystem;
        window.showRelationshipSetup = showRelationshipSetup;
        window.generateRandomRelationships = generateRandomRelationships;
        window.clearAllRelationships = clearAllRelationships;
        window.finishRelationshipSetup = finishRelationshipSetup;
        window.backToCastCustomization = backToCastCustomization;
        window.setRelationship = setRelationship;
        window.updateCharacterName = updateCharacterName;
        window.updateCharacterArchetype = updateCharacterArchetype;
        window.updateCharacterStat = updateCharacterStat;
        window.randomizeCast = randomizeCast;
        window.startMovie = startMovie;
        window.selectKillerPlayer = selectKillerPlayer;
        window.showKillTargets = showKillTargets;
        window.cancelKillAction = cancelKillAction;
        window.attemptKill = attemptKill;
        window.performPsychOut = performPsychOut;
        window.plantEvidence = plantEvidence;
        window.hideAndWait = hideAndWait;
        window.forceKillerAction = forceKillerAction;
        window.continueStory = continueStory;
        window.toggleAutoplay = toggleAutoplay;
        window.skipToEnd = skipToEnd;
        window.viewResults = viewResults;
        window.createSequel = createSequel;
        window.confirmSurvivorSelection = confirmSurvivorSelection;
        window.cancelSurvivorSelection = cancelSurvivorSelection;
        window.resetSimulator = resetSimulator;
    
function updateStatusSidebar() {
    const list = document.getElementById("status-list");
    if (!list) return;
    list.innerHTML = "";
    gameState.characters.forEach(c => {
        const li = document.createElement("li");
        const icon = c.status === "Alive" ? "☘️" : "☠️";
        li.innerHTML = icon + " <strong>" + c.name + "</strong> <span style='color:#888;'>(" + c.archetype.name + ")</span>";
        li.style.marginBottom = "6px";
        list.appendChild(li);
    });
    document.getElementById("").style.display = "block";
}

const originalAddEvent = addEvent;
addEvent = function(type, text) {
    originalAddEvent(type, text);
    
};


function updateCastGridStatus() {
    const container = document.getElementById("cast-grid-status");
    if (!container) return;

    container.innerHTML = "";

    const characters = [...gameState.characters];

    characters.sort((a, b) => {
        if (a.status === "Alive" && b.status !== "Alive") return 1;
        if (b.status === "Alive" && a.status !== "Alive") return -1;
        if (a.deathAct && b.deathAct) return b.deathAct - a.deathAct;
        return 0;
    });

    characters.forEach(c => {
        const span = document.createElement("span");
        span.style.padding = "6px 10px";
        span.style.borderRadius = "5px";
        span.style.background = c.status === "Alive" ? "#2e7d32" : "#b71c1c";
        span.style.color = "#fff";
        span.style.fontSize = "13px";
        span.innerHTML = `${c.name} <small style='opacity:0.7;'>(${c.archetype.name})</small>`;
        container.appendChild(span);
    });
}

</script>
</body>
</html>
